                                                                        [ 文件 ] [ txt | PDF ] [ 草案-IETF-AVT-RT ... ] [ DIFF1 ] [ DIFF2 ] [ 勘误 ]         更新：5506，5761，6051，6222，7022，7160，Internet标准7164，8083，8108 勘误存在
                                                                        

                                            
网络工作组H. Schulzrinne
要求评论：3550哥伦比亚大学
Obsletes：1889                                                S. Casner
类别：标准跟踪包设计
                                                            弗雷德里克
                                                  蓝色外套系统公司
                                                             雅各布森
                                                           数据包设计
                                                               二○○三年七月


          RTP：用于实时应用的传输协议

本备忘录的状态

   本文档规定了Internet标准协议
   互联网社区，并请求讨论和建议
   改进。请参考当前版本的“互联网”
   官方协议标准“（STD 1）
   和该协议的状态。此备忘录的分发是无限制的。

版权声明

   版权所有（C）互联网协会（2003）。版权所有。

抽象

   该备忘录描述了RTP，即实时传输协议。RTP
   提供适合的端到端网络传输功能
   传输实时数据的应用，如音频，视频或
   模拟数据，通过组播或单播网络服务。RTP
   不处理资源预留，不保证
   实时服务质量服务。数据传输是
   由控制协议（RTCP）增强，以允许监视
   数据传输方式可扩展到大型组播网络，
   以提供最小的控制和识别功能。RTP和
   RTCP被设计为独立于底层传输和
   网络层。该协议支持使用RTP级别
   翻译和混音器。

   大多数在这个备忘录的文本是相同的RFC 1889，它
   淘汰了。电线上的数据包格式没有变化，
   只有修改规则和算法才能控制协议
   用来。最大的变化是可扩展定时器的增强
   用于计算何时发送RTCP数据包的算法
   尽量减少传输超过预期的速率
   参与者同时加入一个会话。




Schulzrinne等人 标准履历[第1页]
 
RFC 3550                           RTP July 2003


目录

   1。介绍................................................    4 
       1.1   术语............................................    5 
   2。RTP使用场景...........................................    5 
       2.1   简单组播音频会议.......................    6 
       2.2   音频和视频会议.................... .........    7 
       2.3   搅拌机和翻译机.................................    7 
       2.4   分层编码......................................    8 
   3。定义.................................................    8 
   4。字节顺序，对齐，  和时间格式..................... 12 
   5。RTP数据传输协议.................................   13 
       5.1   RTP固定标题字段...... ..........................   13 
       5.2   多路复用RTP会话................... ...........   16 
       5.3   对RTP头的配置文件特定修改.......   18 
            5.3.1   RTP头扩展............... .............   18 
   6。RTP控制协议 -  RTCP ................................   19 
       6.1   RTCP数据包格式....... ..............................   21 
       6.2   RTCP传输间隔............... ..............  
            
       
            
            
            
            
            
            
            
            
            
       
            
            
            
            
       
            6.5.1 CNAME：规范端点标识符SDES项目。46
            52 7。RTP转换器和混频器..................................   53 7.1   概述........ ............................   53
            
            
            
            
            
            
       
       
   
       



Schulzrinne等人 标准轨迹[第2页]
 
RFC 3550                           RTP July 2003


       7.2   转换器中的RTCP处理.........................   55 
       7.3   混频器中的RTCP处理............. ................   57台
       7.4   级联搅拌机.............................. ...........   58 
   8。SSRC标识符分配和使用..........................   59 
       8.1   碰撞概率.............. .................   59 
       8.2   碰撞分辨率和环路检测...............   60 
       8.3   使用分层编码.... .........................   64 
   9。安全................................................. ...   65 
       9.1   保密.............  ........................... 65 
       9.2   认证和消息完整性................. ..   67 
   10。拥塞控制..........................................   67 
   11。RTP over网络和传输协议....................   68 
   12。协议常数摘要...............................   69 
       12.1 RTCP数据包类型.......... ............................   70 
       12.2 SDES类型.................. ...........................   70 
   13。RTP配置文件和有效载荷格式规范..............   71 
   14。安全考虑.....................................  73 
   15。IANA注意事项.........................................   73 
   16。知识产权声明.....................   74 
   17。致谢.............................................   74 
   附录A。算法........................................   75 
   附录A.1   RTP数据头的有效性检查...................   78 
   附录A.2   RTCP标题有效性检查..................... ..   82 
   附录A.3   确定预期和丢失的数据包数量   83 
   附录A.4   生成RTCP SDES数据包......................  84 
   附录A.5   解析RTCP SDES数据包.........................   85 
   附录A.6   生成随机32位标识符.... .........   85 
   附录A.7   计算RTCP传输间隔..........   87 
   附录A.8   估计区域间抖动............ ....   94 
   附录B。从变化RFC 1889 .............................   95 
   参考资料............... ....................................... 100 
   规范性参考........ .................................... 100 
   资料性参考........... ...............................
















Schulzrinne等人 标准轨迹[第3页]
 
RFC 3550                           RTP July 2003


1。介绍

   本备忘录规定了实时传输协议（RTP），
   它为实时数据提供端到端传送服务
   特色，如互动音视频。那些服务
   包括有效载荷类型识别，序列号，时间戳
   和送货监控。应用程序通常在其上运行RTP
   UDP使用其复用和校验和服务; 都
   协议贡献了传输协议功能的一部分。
   然而，RTP可以与其他合适的底层网络一起使用
   运输协议（见第11节）。RTP支持数据传输
   使用组播分发的多个目的地由...提供
   底层网络。

   请注意，RTP本身并没有提供任何确保及时的机制
   交付或提供其他服务质量保证，但依赖
   对下层服务这样做。不保证交货或
   防止无序传送，也不会假设潜在的
   网络可靠，并按顺序传送数据包。顺序
   包含在RTP中的数字允许接收机重建
   发送方的数据包序列，但也可以使用序列号
   确定数据包的正确位置，例如在视频中
   解码，而不必依次解码数据包。

   RTP主要是为了满足多媒体
   参与者多媒体会议，但不限于此
   特殊应用。存储连续数据，互动
   分布式仿真，活动徽章，以及控制和测量
   应用程序也可能会发现RTP适用。

   本文档定义了RTP，由两个紧密相连的部分组成：

   o实时传输协议（RTP），携带具有的数据
      实时属性。

   o RTP控制协议（RTCP），用于监控服务质量
      并传达关于参与者的信息
      会话。RTCP的后一方面可能足以“松散地”
      控制“的会话，即没有明确的会员资格
      控制和设置，但并不一定意图支持
      所有应用程序的控制通信要求。这个
      功能可以完全或部分归结为单独的
      会话控制协议，超出了这个范围
      文件。

   RTP代表了遵循以下原则的新型协议
   应用层框架和集成层处理提出
   Clark和Tennenhouse [ 10 ]。也就是说，RTP是可塑性的



Schulzrinne等人 标准履历[第4页]
 
RFC 3550                           RTP July 2003


   提供特定应用程序所需的信息
   经常被整合到应用程序处理中，而不是
   被实现为一个单独的层。RTP是一个协议框架
   这是故意不完整的。本文件规定了这些
   功能预期在所有应用程序中都是共同的
   RTP是合适的。不同于传统协议
   可以通过协议来实现附加功能
   更通用或通过添加需要的选项机制
   解析，RTP旨在通过修改和/或
   根据需要添加标头。示例在章节中给出
   5.3和6.4.3。

   所以，除了这个文件外，还有一个完整的规范
   特定应用程序的RTP将需要一个或多个同伴
   文件（见第13节）：

   oa配置文件规范文档，它定义了一组有效载荷
      类型代码和它们到有效载荷格式的映射（例如，媒体
      编码）。配置文件也可以定义扩展或修改
      到特定类别的应用程序的RTP。
      通常，应用程序将仅在一个配置文件下运行。一个
      音频和视频数据的配置文件可以在RFC 
      3551 [ 1 ]中找到。

   o有效载荷格式说明文件，它们定义如何
      特定有效载荷，例如音频或视频编码
      在RTP中携带。

   对他们的实时服务和算法的讨论
   实施以及对一些RTP的背景讨论
   设计决策可以在[ 11 ]中找到。

1.1术语

   关键词“必须”，“不得”，“需要”，“应该”，“不”
   这个“应该”，“不应该”，“推荐”，“可能”和“可选”
   如上述文件中被解释BCP 14，RFC 2119 [ 2 ]
   并指示符合RTP实现的要求级别。

2。RTP使用场景

   以下部分描述了使用RTP的一些方面。该
   选择了实例来说明基本操作
   使用RTP的应用程序，不限制可能使用什么RTP。在
   这些示例，RTP是承载在IP和UDP之上，并遵循
   指定的音频和视频配置文件建立的约定
   在RFC 3551的伴侣中。




Schulzrinne等人 标准履历[第5页]
 
RFC 3550                           RTP July 2003


2.1简单组播音频会议

   IETF的一个工作组举行会议，讨论最新的协议
   文件，使用互联网的IP组播服务进行语音
   通信。通过一些分配机制的工作组
   主席获取组播组地址和端口对。一口
   用于音频数据，另一个用于控制（RTCP）
   数据包。这个地址和端口信息被分配给
   预期参与者。如果需要隐私，数据和控制
   数据包可以按照第9.1节的规定进行加密，在这种情况下
   还必须生成和分发加密密钥。最正确
   这些分配和分配机制的细节已经超越了
   RTP的范围。

   每个会议使用的音频会议应用程序
   参与者以例如20ms持续时间的小块发送音频数据。
   每个音频数据块之前都有一个RTP头; RTP头和
   数据又包含在UDP数据包中。RTP头指示
   包含什么类型的音频编码（如PCM，ADPCM或LPC）
   在每个数据包中，以便发送者可以在a期间更改编码
   会议，例如，适应一个新的参与者
   通过低带宽链路连接或对其进行反应
   网络拥塞

   互联网，像其他分组网络，偶尔会丢失
   重新排序数据包并将其延迟可变的时间量。至
   应对这些损伤，RTP头包含定时
   信息和允许接收器的序列号
   重建源头所产生的时间，以此在此
   例如，音箱大量播放扬声器
   每20毫秒 这个定时重建是分开进行的
   会议中每个RTP包的来源。序列号
   也可以被接收机用来估计有多少个数据包
   失去了

   由于工作组成员在此期间加入并离开
   会议，了解谁在任何时候参与是有用的
   以及他们如何接收音频数据。为了这个目的，
   音频应用程序的每个实例定期在会议中
   在RTCP上组播接收报告加上其用户名
   （控制）端口。接收报告表明当前的状况
   正在接收扬声器并且可以用来控制自适应
   编码。除了用户名，其他识别
   信息也可以包含受控带宽限制。
   一个站点在离开时发送RTCP BYE数据包（6.6节）
   会议。





Schulzrinne等人 标准轨迹[第6页]
 
RFC 3550                           RTP July 2003


2.2音视频会议

   如果在会议中使用音频和视频媒体，则它们是
   作为单独的RTP会话传输。也就是说，单独的RTP和RTCP
   使用两个不同的UDP端口为每个媒体传输数据包
   对和/或多播地址。没有直接耦合
   音频和视频会话之间的RTP级别，除了用户
   参加这两个会议应该使用相同的区别
   （规范）名称在RTCP数据包中，以便会话
   可以关联。

   这种分离的一个动机是允许一些参与者
   会议只能选择一种媒体。进一步第5.2节 
   给出了解释。尽管分离，
   可以实现源的音频和视频的同步播放
   使用RTCP数据包中携带的定时信息
   会话。

2.3搅拌机和翻译机

   到目前为止，我们假设所有网站都希望接收媒体数据
   相同的格式。但是，这并不总是适合的。
   考虑一个区域的参与者连接的情况
   通过低速连接到大多数会议
   享受高速网络访问的参与者。而不是强迫
   大家使用低带宽，低质量的音频编码，
   被称为混频器的RTP级继电器可以放置在低带宽附近
   区。该混音器重新同步传入音频数据包
   重建由发送者产生的恒定的20 ms间隔，混合
   将这些重构的音频流转换为单个流，进行翻译
   音频编码到较低带宽的一个，
   带宽分组流穿过低速链路。这些数据包
   可能单播到单个接收者或组播不同
   地址到多个收件人 RTP报头包括一个装置
   混合器来识别有助于混合数据包的源
   可以在接收器处提供正确的讲话者指示。

   音频会议的一些预期参与者可能是
   连接高带宽链路，但可能不直接
   通过IP组播可达。例如，他们可能在后面
   不会让任何IP包通过的应用级防火墙。
   对于这些网站，混合可能不是必需的，在这种情况下可能不是必需的
   可以使用称为转换器的RTP级继电器的类型。二
   安装了翻译器，一个位于防火墙的两边
   外部一个漏斗通过一个接收到的所有组播数据包
   与防火墙内的翻译器的安全连接。该
   防火墙内的翻译者再次将其作为组播数据包发送
   到限制到站点的内部网络的多播组。



Schulzrinne等人 标准轨迹[第7页]
 
RFC 3550                           RTP July 2003


   搅拌机和翻译机可以设计用于各种目的。一个
   例如，可以对个人的图像进行缩放的视频混合器
   在单独的视频流中，将它们复合成一个视频流
   模拟一个群组场景。翻译的其他例子包括
   连接一组只有IP / UDP的主机组成一组
   仅了解ST-II或逐个包编码的主机
   来自个别来源的视频流的翻译
   重新同步或混合。搅拌机的操作细节
   翻译员在第7节中给出。

2.4分层编码

   多媒体应用应能够调整传输
   速率匹配接收机的容量或适应网络
   拥塞。许多实施方式，
   来源的适应性。这对于多播是不正常的
   传输因为带宽要求的冲突
   异构接收机 结果通常是最不常见的
   网络中最小的管道网格中的分母情景
   决定了整体现场多媒体的质量和忠实度
   “广播”。

   相反，速率适应的责任可以放在
   接收机通过组合分层编码与分层传输
   系统。在RTP over IP组播的上下文中，源可以
   对分层代表信号的渐进层进行划分
   跨越多个RTP会话，每个RTP会话都承载在其自己的多播组上。
   接收机可以适应网络的异构性并控制它们
   接收带宽只加入适当的子集
   组播组。

   使用分层编码的RTP的详细信息
   第6.3.9，8.3和11。

3。定义

   RTP有效载荷：数据包中的RTP传输的数据
      示例音频样本或压缩视频数据。有效载荷
      格式和解释超出了本文档的范围。

   RTP包：由固定RTP头组成的数据包，a
      可能是空白的贡献来源列表（见下文）和
      有效载荷数据。一些底层协议可能需要一个
      封装需要定义的RTP包。通常一个
      底层协议的分组包含单个RTP分组，
      但是如果允许，则可能包含几个RTP包
      封装方法（见第11节）。




Schulzrinne等人 标准履历[第8页]
 
RFC 3550                           RTP July 2003


   RTCP包：由固定头部分组成的控制包
      类似于RTP数据包，其次是结构化
      根据RTCP数据包类型而变化的元素。该
      格式在第6节中定义。通常，多个RTCP
      分组一起作为复合RTCP分组一起发送
      数据包的底层协议; 这是由长度启用的
      字段在每个RTCP分组的固定报头中。

   端口：传输协议使用的抽象
      区分给定主机内的多个目的地
      电脑。TCP / IP协议识别端口使用小的正数
      整数“。[ 12 ] OSI使用的传输选择器（TSEL）
      传输层相当于端口。RTP取决于
      下层协议提供端口等一些机制
      复用会话的RTP和RTCP数据包。

   传输地址：组合网络地址和端口
      其标识传输级端点，例如IP
      地址和UDP端口。数据包从源传输
      运输地址到目的地的运输地址。

   RTP媒体类型：RTP媒体类型是有效载荷的集合
      可以在单个RTP会话中携带的类型。RTP
      配置文件将RTP媒体类型分配给RTP有效载荷类型。

   多媒体会话：一组并发RTP会话
      共同参与者群体。例如，视频会议
      （其是多媒体会话）可以包含音频RTP会话
      和视频RTP会话。

   RTP会话：一组参与者之间的关联
      与RTP通信。参与者可能涉及多个
      RTP会话同时进行。在多媒体会话中，每个
      媒介通常以独立的RTP会话携带
      RTCP包，除非编码本身复用多个
      媒体转换为单个数据流。参与者区分
      通过接收不同会话使用多个RTP会话
      不同的目的地传输地址对，其中一对
      的传输地址包括一个网络地址加一对
      的RTP和RTCP端口。RTP会话中的所有参与者可以
      共享一个共同的目的地传输地址对，如在这种情况下
      的IP组播，或者对于每个组可能是不同的
      参与者，如单个单播网络的情况
      地址和端口对。在单播情况下，参与者可以
      从会话中的所有其他参与者接收使用相同的
      一对端口，或者可以为每个端口使用不同的端口。





Schulzrinne等人 标准履历[第9页]
 
RFC 3550                           RTP July 2003


      RTP会话的区别特征是每个
      维护一个完整的，独立的SSRC标识符空间（定义
      下一个）。一组参与者包括在一个RTP会话中
      由可以接收发送的SSRC标识的那些组成
      由RTP作为SSRC的任何一方或中国证监会
      （也在下面定义）或在RTCP中。例如，
      使用单播UDP实现的第三方会议
      参与者从另外两个在单独的端口对接收。
      如果每个参与者发送关于从中接收到的数据的RTCP反馈
      另一个参与者只回到该参与者，然后
      会议由三个单独的点对点RTP组成
      会话。如果每个参与者提供关于它的RTCP反馈
      另外另一个参与者的接待
      参加者，则会议由一个多方组成
      RTP会话。后一种情况模拟行为
      发生在三者之间的IP组播通信
      参与者。

      RTP框架允许在这里定义的变体，但是a
      通常特定的控制协议或应用设计
      对这些变体施加约束。

   同步源（SSRC）：RTP流的源
      由携带的32位数字SSRC标识符标识的数据包
      RTP报头，以便不依赖于网络地址。
      来自同步源的所有数据包构成相同的一部分
      定时和序列号空格，所以接收者将数据包分组
      同步源播放。同步示例
      源包括从a导出的分组流的发送者
      信号源，例如麦克风或照相机，或RTP混频器
      （见下文）。同步源可能会改变其数据格式，
      例如，随着时间的推移音频编码。SSRC标识符是a
      随机选择的值意味着在全球范围内是独一无二的
      特定RTP会话（参见第8节）。参与者不需要
      对于所有RTP会话使用相同的SSRC标识符
      多媒体会话; SSRC标识符的绑定是
      通过RTCP提供（见第6.5.1节）。如果参与者
      在一个RTP会话中生成多个流，例如从
      单独的摄像机，每个必须被标识为不同的
      SSRC。

   贡献来源（CSRC）：RTP数据包流的来源
      这促成了由RTP生成的组合流
      搅拌机（见下文）。混合器插入SSRC的列表
      有助于生成a的源的标识符
      特定的分组进入该分组的RTP报头。这个列表
      被称为中国证监会名单。示例应用程序是音频
      会议中，混音器指示所有讲话者的演讲



Schulzrinne等人 标准履历[第10页]
 
RFC 3550                           RTP July 2003


      被组合以产生传出的分组，允许接收机
      以表示当前的讲话者，即使所有的音频数据包
      包含相同的SSRC标识符（混频器的标识符）。

   结束系统：生成要发送的内容的应用程序
      在RTP分组中和/或消耗接收到的RTP的内容
      数据包。终端系统可以作为一个或多个同步
      特定RTP会话中的源，但通常只有一个。

   混音器：从一个接收RTP数据包的中间系统
      或更多来源，可能会更改数据格式，组合
      分组，然后转发新的RTP分组。以来
      多个输入源之间的时间一般不会
      同步，混音器将进行时序调整
      流，并为组合流生成自己的时序。
      因此，将识别源自混频器的所有数据分组
      作为混频器作为其同步源。

   转换器：转发RTP数据包的中间系统
      其同步源标识符保持不变。示例
      翻译器包括不混合转换编码的设备，
      复制器从组播到单播，以及应用级
      防火墙中的过滤器

   监视器：接收到发送的RTCP数据包的应用程序
      RTP会话中的参与者，特别是接收
      报告，并估计当前的服务质量
      分布监测，故障诊断和长期统计。
      监视器功能很可能内置在应用程序中
      参加会议，但也可能是一个单独的
      没有其他参与且不发送的应用程序
      或接收RTP数据包（因为它们是在一个单独的
      港口）。这些被称为第三方监视器。也是
      可接受第三方监视器接收RTP数据
      数据包，但不发送RTCP数据包或以其他方式计入
      会话。

   非RTP意味着：可能需要的协议和机制
      除了RTP提供可用的服务。特别是
      多媒体会议，控制协议可以分发
      组播地址和密钥进行加密，协商
      要使用的加密算法，并定义动态映射
      在RTP有效载荷类型值和有效载荷格式之间
      代表没有预定义的有效载荷类型的格式
      值。这种协议的示例包括会话发起
      协议（SIP）（RFC 3261 [ 13 ]），ITU建议H.323 [ 14 ]和
      使用SDP（RFC 2327 [ 15 ]）的应用程序，如RTSP（RFC 2326 
      [ 16 ]））。为简单



Schulzrinne等人 标准履历[第11页]
 
RFC 3550                           RTP July 2003


      应用程序，电子邮件或会议数据库也可以
      用过的。这种协议和机制的规范是
      超出本文件的范围。

4。字节顺序，对齐和时间格式

   所有整数字段以网络字节顺序携带，也就是大多数
   首字母（八位字节）。这个字节顺序通常被称为
   大端。传输顺序在[ 3 ] 中有详细描述。
   除非另有说明，否则数字常数为十进制（10位）。

   所有标题数据与其自然长度对齐，即16位字段
   在偶数偏移上对齐，32位字段在偏移处对齐
   由四等分，等等。指定为填充的八位字节具有值
   零。

   Wallclock时间（绝对日期和时间）使用
   网络时间协议（NTP）的时间戳格式
   1900年1月1日相对于0h UTC的秒数[ 4 ]。充分
   分辨率NTP时间戳是具有64位无符号定点数
   前32位中的整数部分和
   最后32位。在一些更紧凑的表示方面的领域
   适当的，只使用中间的32位; 那就是低点16
   整数部分的位和小数部分的高16位。
   必须确定整数部分的高16位
   独立。

   不需要在其中运行网络时间协议的实现
   命令使用RTP。可以使用其他时间来源，也可以不使用
   （请参见第6.4.1节中的NTP时间戳记字段的描述）。
   但是，运行NTP可能对同步流有用
   从单独的主机传输。

   一年中的NTP时间戳将会绕过零
   2036，但对于RTP目的，只有NTP对之间的差异
   使用时间戳。只要这对时间戳可以
   假设在68年之内，使用模数运算
   对于减法和比较使得环绕无关。













Schulzrinne等人 标准轨迹[第12页]
 
RFC 3550                           RTP July 2003


5。RTP数据传输协议

5.1 RTP固定标题字段

   RTP报头具有以下格式：

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | V = 2 | P | X | CC | M | PT | 序号|
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | 时间戳|
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | 同步源（SSRC）标识符|
   + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +
   | 贡献来源（CSRC）标识符|
   | .... |
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   前12个八位字节存在于每个RTP包中，而
   仅当通过混音器插入时才会出现CSRC标识符列表。
   这些字段具有以下含义：

   版本（V）：2位
      此字段标识RTP的版本。版本定义
      这个规范是两（2）。（值1由第一个使用
      RTP的草案版本，协议使用的值为0
      最初在“大桶”音频工具中实现。）

   填充（P）：1位
      如果填充位被置位，则该数据包包含一个或多个
      额外的填充八位字节在结尾不是的一部分
      有效载荷。填充的最后一个八位字节包含如何计数
      许多填充字节应该被忽略，包括它自己。填充
      可能需要一些具有固定块大小的加密算法
      或者用于在较低层协议数据中携带多个RTP分组
      单元。

   扩展（X）：1位
      如果扩展位被设置，固定头部必须紧跟着
      一个标头扩展名，具有第
      5.3.1节中定义的格式。

   CSRC计数（CC）：4位
      中国证监会的数量包含随后的证监会标识符数量
      固定标题。





Schulzrinne等人 标准履历[第13页]
 
RFC 3550                           RTP July 2003


   标记（M）：1位
      标记的解释由轮廓定义。它是
      旨在允许诸如帧边界等重大事件
      在数据包流中进行标记。个人资料可以定义附加信息
      标记位或指定通过更改不存在标记位
      有效载荷类型字段中的位数（见第5.3节）。

   有效载荷类型（PT）：7位
      该字段标识RTP有效载荷的格式并确定
      其解释由应用程序。个人资料可以指定一个
      有效载荷类型代码默认静态映射到有效载荷格式。
      可以通过动态定义附加的有效载荷类型代码
      非RTP方式（见第3节）。一组默认映射
      音频和视频在RFC 3551 [ 1 ] 中指定。一个
      RTP源可以在会话期间更改有效载荷类型，但是这可以
      字段不应该用于复用单独的媒体流
      （见第5.2节）。

      接收者必须忽略不具有有效载荷类型的数据包
      理解。

   序列号：16位
      每个RTP数据包的顺序号递增1
      发送，并且可以被接收机用来检测分组丢失和
      恢复包序列。序列号的初始值
      应该是随机的（不可预测的）进行已知的明文攻击
      加密更加困难，即使源本身没有
      按照9.1节的方法进行加密，因为
      数据包可能会流经翻译器。技术为
      在[ 17 ] 中讨论了选择不可预测的数字。

   时间戳：32位
      时间戳记反映了第一个八位字节的采样时刻
      RTP数据包。采样时刻必须从a得到
      在时间上单调递增的时钟允许的时钟
      同步和抖动计算（见第6.4.1节）。该
      时钟的分辨率必须足够用于所需的时钟
      同步精度和测量数据包到达抖动
      （每个视频帧一个刻度通常不足）。时钟
      频率取决于作为有效载荷携带的数据格式
      并以配置文件或有效载荷格式静态指定
      规范定义格式，或可以指定
      动态地为通过非RTP方式定义的有效载荷格式。如果
      RTP包定期生成，标称采样
      使用从采样时钟确定的即时是不是一个
      读取系统时钟。例如，对于固定速率音频
      时间戳时钟可能会为每个增加一个
      抽样期。如果音频应用程序读取块覆盖



Schulzrinne等人 标准轨迹[第14页]
 
RFC 3550                           RTP July 2003


      来自输入设备的160个采样周期，时间戳将是
      每个这样的块增加160，不管是否
      块在数据包中传输或以静默方式丢弃。

      时间戳的初始值应该是随机的
      序列号。几个连续的RTP数据包将相等
      时间戳，如果它们（逻辑上）一次生成，例如属于
      到同一个视频帧。连续RTP包可能包含
      如果不发送数据，则不会单调的时间戳
      按照其被采样的顺序，如在MPEG内插的情况下
      视频帧。（发送的数据包的序列号
      仍将是单调的。）

      来自不同媒体流的RTP时间戳可以在
      通常具有独立的随机偏移率。
      因此，虽然这些时间戳足以重构
      单个流的定时，直接比较RTP时间戳
      从不同的媒体对同步是无效的。
      相反，对于每个媒体，RTP时间戳与
      通过将其与引用的时间戳配对来进行采样
      时钟（wallclock）表示数据的时间
      对应于RTP时间戳被采样。参考
      时钟由所有要同步的媒体共享。时间戳
      在每个数据包中都不传输对，但是在较低的数据包中
      速率在RTCP SR包中，如第6.4节所述。

      选择采样时刻作为参考点
      RTP时间戳，因为它是传输端点和
      对所有媒体都有一个共同的定义，与编码无关
      延误或其他处理。目的是允许同步
      介绍所有媒体同时采样。

      应用传输存储数据而不是采样中的数据
      实时通常使用衍生的虚拟演示时间轴
      从wallclock时间确定下一帧或其他单位的时间
      应显示存储数据中的每个介质。在这个
      情况下，RTP时间戳将反映出演示时间
      每个单位。也就是说，每个单元的RTP时间戳将是
      与该单元变为当前的挂钟时间有关
      虚拟演示时间线。实际演示发生
      一段时间后由接收机确定。

      描述预录视频的实时音频叙述的一个例子
      说明了选择采样时刻的意义
      参考点。在这种情况下，视频将是
      在本地提供叙述者观看和将来
      同时使用RTP传输。a的“取样时刻”
      在RTP中传输的视频帧将通过引用来建立



Schulzrinne等人 标准履历[第15页]
 
RFC 3550                           RTP July 2003


      它的时间戳到那个视频帧的时钟时间
      提交给叙述者。音频RTP的采样时刻
      包含叙述者演讲的数据包将由...建立
      引用音频采样时的相同时钟。
      如果音频和视频甚至可以由不同的主机发送
      两台主机上的参考时钟同步一些
      手段如NTP。接收者可以同步呈现
      的音频和视频数据包通过关联它们的RTP时间戳
      使用RTCP SR数据包中的时间戳对。

   SSRC：32位
      SSRC字段标识同步源。这个
      标识符应该随机选择，意图是没有两个
      同一RTP会话中的同步源将具有
      相同的SSRC标识符。一个生成a的例子算法
      随机识别符见附录A.6。虽然
      多个来源选择相同标识符的概率是
      低，所有RTP实现必须准备检测和
      解决碰撞  第8节描述了概率
      碰撞以及解决冲突的机制
      基于唯一性检测RTP级转发循环
      SSRC标识符。如果源更改其源传输
      地址，它还必须选择一个新的SSRC标识符来避免
      解释为循环源（参见第8.2节）。

   中国证监会清单：0〜15个项目，每个32位
      中国证监会清单确定有效载荷的贡献来源
      包含在此包中。标识符的数量由...给出
      CC字段。如果有超过15个贡献来源，
      只能识别15个。CSRC标识符插入
      混合器（见第7.1节），使用SSRC标识符
      贡献来源 例如，对于SSRC的音频数据包
      混合在一起创建的所有来源的标识符
      列出了数据包，允许正确的通话者指示
      接收器。

5.2复用RTP会话

   为了有效的协议处理，复用点的数量
   应该最小化，如集成层处理中所述
   设计原则[ 10 ]。在RTP中，由...提供复用
   目的地传输地址（网络地址和端口号）哪个
   对于每个RTP会话是不同的。例如，在电话会议中
   组成音视频媒体单独编码，每个媒体
   应该在与其自己的目的地的单独RTP会话中携带
   运输地址。





Schulzrinne等人 标准履历[第16页]
 
RFC 3550                           RTP July 2003


   单独的音频和视频流不应该单独携带
   RTP会话并基于有效载荷类型或SSRC进行解复用
   领域。用不同的RTP媒体类型交织数据包
   使用相同的SSRC会引入几个问题：

   如果说两个音频流共享相同的RTP会话和
      相同的SSRC值，一个是改变编码，从而获得
      不同的RTP负载类型，将不会有一般的方式
      识别哪个流已经改变了编码。

   2.定义SSRC来识别单个时序和序列号
      空间。需要交换多个有效载荷类型
      不同的时间空间，如果媒体时钟速率不同，会
      需要不同的序列号空格来判断哪个有效载荷
      类型遭受丢包。

   3. RTCP发送方和接收方报告（见第6.4节）
      描述每个SSRC的一个时序和序列号空间，不要
      携带有效载荷类型字段。

   RTP混合器将不能组合交织流
      不兼容的媒体成一个流。

   5.在一个RTP会话中携带多个媒体排除：使用
      不同的网络路径或网络资源分配如果
      适当; 如果需要，接收媒体的子集
      例如，如果视频超过可用带宽，则只是音频;
      以及使用单独进程的接收器实现
      不同的媒体，而使用单独的RTP会话允许
      单进程或多进程实现。

   对每个媒体使用不同的SSRC，但是将它们发送到同一个媒体
   RTP会话将避免前三个问题，而不是最后一个
   二。

   另一方面，复用多个相关的相关源
   在一个RTP会话中使用不同SSRC值的媒体是规范
   组播会话。上面列出的问题不适用于：RTP
   混音器可以组合多个音频源，例如，相同
   所有这些都适用。也可能是适当的
   以使用不同的SSRC值来复用相同介质的流
   在其他情况下，最后两个问题不适用。









Schulzrinne等人 标准履历[第17页]
 
RFC 3550                           RTP July 2003


5.3对RTP头的配置文件特定修改

   现有的RTP数据包头被认为是完整的
   所有应用程序所需的一组功能共同
   RTP可能支持的类。但是，与ALF保持一致
   设计原则，标题可以通过修改或
   在配置文件规范中定义的添加，同时仍然允许
   配置文件独立的监控和记录工具功能。

   o标记位和有效负载类型字段携带特定于配置文件
      信息，但是它们被分配在固定头中，因为很多
      应用程序预计需要它们，否则可能需要它们
      添加另一个32位字只是为了保持它们。八位字节包含
      这些字段可能被一个配置文件重新定义，以适应不同的
      要求，例如具有更多或更少的标记位。如果
      有任何标记位，一个应该位于最多
      独立于显示器的八位字节的有效位
      可以观察到丢包模式之间的相关性
      和标记位。

   o特定有效载荷所需的附加信息
      格式，如视频编码，应该在有效载荷中携带
      分组的部分。这可能是始终在一个标题
      出现在有效载荷部分的开头，或可能被指示
      通过数据模式中的保留值。

   o如果特定类别的应用程序需要额外的
      功能独立于有效载荷格式，下面的配置文件
      哪些应用程序操作应该定义额外的固定
      现场的SSRC领域之后立即跟踪
      固定标题。那些应用程序将能够快速和
      直接访问附加字段，而与个人资料无关
      监视器或录像机仍然可以处理RTP数据包
      仅解释前十二个八位字节。

   如果事实证明需要额外的功能
   在所有配置文件中，应定义新版本的RTP
   对固定标题进行永久更改。

5.3.1 RTP报头扩展

   提供扩展机制以允许个人
   实现新的有效载荷格式无关
   需要在其中携带附加信息的功能
   RTP数据包头。这个机制是这样设计的
   标头扩展可能被其他互操作忽略
   尚未扩展的实现。




Schulzrinne等人 标准轨迹[第18页]
 
RFC 3550                           RTP July 2003


   请注意，此扩展名仅用于有限的使用。
   这种机制的最大潜在用途将是另一个更好的做法
   方法，使用上一节中描述的方法。对于
   例如，固定标题的特定于配置文件的扩展名较少
   因为它不是条件的也不是变量，因此处理费用很高
   位置。特定有效载荷所需的附加信息
   格式不应该使用这个标头扩展名，但应该进行
   分组的有效载荷部分。

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | 由profile |定义 长度|
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | 标题扩展名|
   | .... |

   如果RTP头中的X位为1，则为可变长度头
   扩展必须在CSRC列表之后附加到RTP头
   如果存在。标题扩展名包含一个16位长度的字段
   计算扩展中32位字的数量，不包括
   四字节扩展头（因此零是有效的长度）。只要
   一个扩展可以附加到RTP数据头。允许
   每个实验的多个互操作实现
   独立地使用不同的标题扩展名，或允许a
   具体实现多种类型的实验
   标题扩展名，标题扩展名的前16位是剩余的
   打开区分标识符或参数。的格式
   这16位将由下面的配置文件规范定义
   哪些实现正在运行。这个RTP规范
   没有定义任何标头扩展本身。

6。RTP控制协议 -  RTCP

   RTP控制协议（RTCP）是基于周期性传输
   的控制数据包到会话中的所有参与者，使用相同的
   分发机制为数据包。底层协议
   必须提供数据和控制数据包的复用
   示例使用单独的端口号与UDP。RTCP执行四个
   功能：

   1.主要功能是提供有关质量的反馈
      数据分发。这是RTP作用的组成部分
      一种传输协议，与流量和拥塞有关
      的其它传输协议控制功能（见第10节上
      拥塞控制的要求）。反馈可能是
      用于自适应编码[控制直接有用18，19 ]，但
      IP多播的实验表明它也是



Schulzrinne等人 标准履历[第19页]
 
RFC 3550                           RTP July 2003


      从接收器获取反馈以诊断故障至关重要
      分配。向所有人发送接收反馈报告
      参与者允许正在观察问题的人评估
      这些问题是地方还是全球问题。有分配
      机制如IP多播，也可能是一个实体
      例如没有涉及的网络服务提供商
      在会议中收到反馈信息并作为
      第三方监视器来诊断网络问题。这个反馈
      功能由RTCP发送者和接收者报告执行，
      如下面第6.4节所述。

   RTCP携带RTP的持久传输级标识符
      源代码称为规范名称或CNAME，第6.5.1节。以来
      如果发现冲突，则SSRC标识符可能会更改
      程序重新启动，接收器要求CNAME跟踪
      每个参与者。接收者也可能需要CNAME
      关联一组中给定参与者的多个数据流
      的相关RTP会话，例如同步音频和
      视频。媒体间同步还需要NTP和RTP
      数据发送者在RTCP数据包中包含的时间戳。

   前两个功能要求所有参与者发送RTCP
      数据包，因此必须控制速率才能使RT​​P达到
      扩大到大量参与者。通过拥有每个
      参与者将其控制数据包发送给所有其他数据包，每个可以
      独立观察参与人数。这个数字是
      用于计算发送数据包的速率
      在第6.2节中解释。

   4.第四个可选功能是传达最少的会话控制
      信息，例如参与者身份
      显示在用户界面中。这很有可能是有用的
      在参与者进入的“松散控制”会议中
      离开没有会员控制或参数协商。RTCP
      作为通向所有参与者的便利通道，但是
      不一定有望支持所有的控制
      应用程序的通信要求。更高层次
      会话控制协议，超出了这个范围
      文件，可能需要。

   功能1-3应该在所有环境中使用，特别是在
   IP组播环境。RTP应用设计人员应该避免
   机制只能在单播模式下工作，不能扩展
   更大的数字。RTCP的传输可以单独控制
   对于发件人和接收者，如第6.2节所述，针对案件
   例如来自接收机的反馈不是单向链路
   可能。




Schulzrinne等人 标准履历[第20页]
 
RFC 3550                           RTP July 2003


   非规范性说明：在组播路由方式中
      称为源特定多播（SSM），只有一个发送方
      每个“通道”（源地址，组地址对）和
      接收器（通道源除外）不能使用多播
      与其他渠道成员直接沟通。该
      这里建议适应SSM只能通过第6.2节的
      完全关闭接收器RTCP的选项。未来的工作会
      指定适用于SSM的RTCP，以便来自接收器的反馈
      可以维护。

6.1 RTCP包格式

   该规范定义了几个RTCP数据包类型
   各种控制信息：

   SR：发件人报告，用于传输和接收统计
         参与者是活跃的发件人

   RR：接收者报告，用于接收参与者的统计
         这不是活动的发件人，并与SR结合使用
         主动发送者报告了31多个来源

   SDES：源描述项，包括CNAME

   BYE：表示参与结束

   APP：应用专用功能

   每个RTCP数据包以类似于RTP数据的固定部分开始
   数据包，其次是可能是可变的结构化元素
   根据分组类型的长度，但必须在32位结束
   边界。对齐要求和固定长度字段
   包含每个数据包的一部分，使RTCP数据包“可堆叠”。
   多个RTCP数据包可以并排，无需任何干预
   分隔符以形成单个发送的复合RTCP数据包
   低层协议的分组，例如UDP。没有
   复合数据包中单个RTCP数据包的显式计数
   因为下层协议有望提供整体
   长度来确定复合包的结束。

   可以处理复合分组中的每个单独的RTCP分组
   独立地没有对订单或组合的要求
   数据包。然而，为了执行协议的功能，
   将施加以下限制：







Schulzrinne等人 标准履历[第21页]
 
RFC 3550                           RTP July 2003


   o接收统计（在SR或RR）应该频繁发送
      带宽限制将允许最大化分辨率
      统计，因此每个周期性发送复合RTCP
      数据包必须包括报告数据包。

   o新的接收者需要尽快收到来源的CNAME
      可能识别源并开始关联媒体
      目的如lip-sync，因此每个复合RTCP包也必须
      包括SDES CNAME，除了复合RTCP数据包
      按照9.1节所述分割部分加密。

   o复合中可能首先出现的数据包类型数
      数据包需要被限制以增加常数位的数量
      在第一个字和成功验证的概率
      RTCP数据包对错误的RTP数据包或其他
      不相关的数据包。

   因此，所有RTCP包必须至少以复合包发送
   两个单独的数据包，格式如下：

   加密前缀：当且仅当要复合数据包时
      根据9.1节中的方法加密，它必须是
      以每个化合物重绘的随机32位数量为前缀
      包传送。如果加密需要填充，那么
      必须添加到复合数据包的最后一个数据包。

   SR或RR：复合数据包中的第一个RTCP数据包必须
      始终是一个报告包，以方便标题验证
      在描述附录A.2。即使没有数据也是如此
      发送或接收，在这种情况下必须发送一个空的RR，甚至是
      如果复合数据包中唯一的其他RTCP数据包是BYE。

   附加RR：如果接收的来源数量
      正在报告的统计数字超过31，将适合的数字
      进入一个SR或RR数据包，然后再附加RR数据包
      初始报告包。

   SDES：必须包含包含CNAME项的SDES数据包
      在每个复合RTCP数据包中，除了第9.1节中所述。
      其他来源描述项目可以包括在内
      由特定应用程序要求，带宽
      约束（见第6.3.9节）。

   BYE或APP：其他RTCP包类型，包括那些尚未被
      定义，可以遵循任何顺序，除了BYE应该是
      与特定SSRC / CSRC发送的最后一个数据包。数据包类型可能会出现
      不止一次。




Schulzrinne等人 标准轨迹[第22页]
 
RFC 3550                           RTP July 2003


   单个RTP参与者应仅发送一个复合RTCP
   每个报告间隔的数据包为了每个RTCP带宽
   参与者要正确估计（见第6.2节），除非
   如所描述的那样，复合RTCP分组被分割用于部分加密
   在9.1节。如果有太多的来源，以适应所有的
   必要的RR分组转换成一个复合RTCP分组，而不超过
   网络路径的最大传输单元（MTU），然后才是
   将适合一个MTU的子集应该包含在每个MTU中
   间隔。子集应该被选择在多个循环中
   间隔，以便报告所有来源。

   推荐翻译器和混音器组合个人RTCP
   来自他们转发的多个来源的数据包
   复合数据包在可行时，以分摊数据包
   间接费用（见第7节）。一个例如RTCP复合数据包
   通过混合器制造如图1所示。如果整体的长度
   复合数据包将超过网络路径的MTU，它应该是
   被分割成要发送的多个较短的复合分组
   在底层协议的单独数据包中。这不会损害
   每个复合分组表示的RTCP带宽估计
   至少有一个不同的参与者。注意每种化合物
   包必须以SR或RR包开始。

   实现应该忽略带有类型的传入RTCP数据包
   未知的 可以注册其他RTCP数据包类型
   互联网号码分配机构（IANA）
   第15节。

   如果加密：随机32位整数
   |
   | [--------- packet --------] [---------- packet ----------] [ -  packet-]
   |
   | 接收块块
   V报告项目项目项目
   -------------------------------------------------- ------------------
   R [SR #sendinfo＃site1＃site2] [SDES #CNAME PHONE #CNAME LOC] [BYE ## why]
   -------------------------------------------------- ------------------
   | |
   | <-----------------------复合数据包----------------------- > |
   | <-------------------------- UDP包-------------------- -----> |

   ＃：SSRC / CSRC标识符

              图1：RTCP复合数据包的示例







Schulzrinne等人 标准履历[第23页]
 
RFC 3550                           RTP July 2003


6.2 RTCP传输间隔

   RTP被设计为允许应用程序自动扩展
   会话大小从几个参与者到数千。对于
   例如，在音频会议中，
   限制因为只有一两个人会一次发言，所以
   组播分配在任何给定链路上的数据速率保持不变
   相对恒定，独立于参与者人数。
   但是，控制流量不是自限制的。如接待
   来自每个参与者的报告以不变的速率发送
   控制流量将随参与者数量呈线性增长。
   因此，速率必须通过动态计算来缩小
   RTCP分组传输之间的间隔。

   对于每个会话，假设数据流量受到限制
   称为“会话带宽”的聚合限制被划分
   参与者们。该带宽可能被保留和限制
   由网络执行 如果没有预约，可能会有
   其他约束，取决于环境，建立
   会议使用的“合理”最大，这将是
   会话带宽。可以基于一些来选择会话带宽
   成本或可用网络带宽的先验知识
   会话。它有点独立于媒体编码，但是
   编码选择可能受到会话带宽的限制。经常，
   会话带宽是发送方的标称带宽的总和
   预计同时活跃。对于电话会议音频，这个
   号码通常是一个发送者的带宽。分层
   编码，每个层都是一个单独的RTP会话与自己的会话
   带宽参数。

   会话带宽参数预计由a提供
   会话管理应用程序在调用媒体应用程序时，
   但媒体应用程序可以基于单发送​​者设置默认值
   为会话选择的编码的数据带宽。该
   应用程序也可以基于多播实施带宽限制
   范围规则或其他标准。所有参与者必须使用相同的
   会话带宽的值，以便相同的RTCP间隔
   计算。

   控制和数据流量的带宽计算包括：
   层传输和网络协议（例如，UDP和IP）
   是资源预留系统需要知道的。该
   应用程序也可以预期知道这些协议中的哪一个
   正在使用。链接级标题不包括在计算中
   该数据包将被封装为不同的链路级标头
   它旅行。





Schulzrinne等人 标准履历[第24页]
 
RFC 3550                           RTP July 2003


   控制流量应限制在一个小而已知的分数
   的会话带宽：小，使主要功能
   传输协议携带数据不受损害; 知道这样
   控制流量可以包含在给定的带宽规范中
   到资源预留协议，并使每个参与者可以
   独立计算其份额。控制流量带宽为
   除了数据流量的会话带宽。它是
   建议为RTCP添加的会话带宽的一部分
   固定在5％。还建议RTCP的1/4
   带宽专用于正在发送数据的参与者
   在与大量接收器的会话中，但少数
   发件人，新加入的参与者将更快收到
   发送站点的CNAME。当发件人的比例是
   大于1/4的参与者，发件人得到他们
   全部RTCP带宽的比例。而这些和的价值
   间隔计算中的其他常数并不重要
   会话参与者必须使用相同的值，所以相同
   间隔将被计算。因此，这些常数应该是
   固定为特定配置文件。

   配置文件可以指定控制流量带宽可以是a
   会话的单独参数而不是严格的百分比
   会话带宽。使用单独的参数允许rate-
   自适应应用设置RTCP带宽与a一致
   “典型”数据带宽低于最大带宽
   由会话带宽参数指定。

   配置文件还可以指定控制流量带宽
   可以分为两个单独的会话参数
   活动数据发送者和不是活动数据发送者的参与者;
   让我们调用参数S和R.按照建议
   该RTCP带宽的1/4用于数据发送器
   这两个参数的推荐默认值为1.25％
   和3.75％。发件人比例较大时
   比S /（S + R）的参与者，发件人得到的比例
   这些参数的总和。使用两个参数允许RTCP
   接收报告完全为特定会话关闭
   通过将非数据发送器的RTCP带宽设置为零
   保持数据发送者的RTCP带宽不为零，以便发送方
   仍然可以发送报告以进行媒体间同步。车削
   因为需要RTCP接收报告不推荐
   特别是在第6节开头列出的功能
   接收质量反馈和拥塞控制。但是，这样做
   可能适用于在单向链路上运行的系统
   对于不需要对接收质量的反馈的会话
   或接收者的活动，并有其他手段来避免
   拥塞。




Schulzrinne等人 标准履历[第25页]
 
RFC 3550                           RTP July 2003


   计算复合RTCP传输间隔
   数据包也应该有一个下限，以避免有爆发
   参与者人数超过允许带宽
   规模小，交通不平坦，依法大
   数字。它也保持报告间隔变得太小
   在诸如网络分区的瞬态停机期间
   分区愈合时适应延迟。申请时
   应该在第一个复合RTCP之前强加一个延迟
   发送数据包以允许RTCP数据包的接收时间
   其他参与者所以报告间隔将会收敛
   更正确的价值。这个延迟可以设置为一半
   最小间隔允许更快地通知新的
   参与者在场。RECOMMENDED值为固定的最小值
   间隔为5秒。

   实现可以将最小RTCP间隔缩小到更小
   值与会话带宽参数成反比
   以下限制：

   o对于组播会话，只有活动数据发送者可以使用
      减小最小值以计算传输间隔
      的复合RTCP数据包。

   o对于单播会话，可以使用减小的值
      参与者也不是活跃的数据发送者，而且
      发送初始化合物RTCP包之前的延迟可能为零。

   o对于所有会话，固定的最小值应该在当时使用
      计算参与者超时间隔（见6.3.5节））
      使得不使用减少值的实现
      传输RTCP数据包不会被其他参与者超时
      过早。

   o减少的最小值（以秒为单位）的RECOMMENDED值为360
      会话带宽除以千比特/秒。这个最小
      对于大于72kb / s的带宽，小于5秒。
设计了6.3节和附录A.7中
   描述的算法
   以实现本节中概述的目标。它计算
   发送复合RTCP数据包之间的间隔，以分配允许
   控制参与者之间的流量带宽。这允许一个
   应用程序为小型会话提供快速响应，for
   例如，所有参与者的身份识别至关重要
   自动适应大会议。该算法结合
   具有以下特点：






Schulzrinne等人 标准履历[第26页]
 
RFC 3550                           RTP July 2003


   o计算出的RTCP数据包之间的间隔与之成线性关系
      该组的成员人数。这是线性因素
      这在总和时允许恒定的控制流量
      跨所有成员

   o RTCP包之间的间隔随机变化
      范围[0.5,1.5]倍的计算间隔，以避免意外
      所有参与者的同步[ 20 ]。第一个RTCP包
      加入会话后发送也随机发生变化
      是最小RTCP间隔的一半。

   o平均复合RTCP包大小的动态估计
      计算，包括接收和发送的所有数据包
      自动适应变化量的控制
      信息携带

   o由于计算的间隔取决于数量
      观察组成员，可能会有不良的启动效应
      当新用户加入现有会话时，或许多用户
      同时加入一个新的会话。最初这些新用户
      对组成员资格进行错误估计，从而对他们进行评估
      RTCP传输间隔太短。这个问题可以
      如果许多用户同时加入会话，这是很重要的。至
      处理这个，一个叫做“定时器重新考虑”的算法就是
      采用。该算法实现简单的退避机制
      这导致用户阻止RTCP包传输
      团体规模正在增加。

   o当用户离开会话时，使用BYE或超时，
      组成员资格减少，因此计算间隔
      应该减少 使用“反向重新考虑”算法
      允许成员更快地减少间隔时间
      组成员资格减少。

   给予BYE数据包与其他RTCP数据包不同的处理。
      当用户离开组，并希望发送一个BYE数据包时
      可能在其下一个计划的RTCP数据包之前执行此操作。然而，
      BYE的传输遵循避免的退避算法
      大量的BYE数据包应该有大量的成员
      同时离开会议

   该算法可用于所有参与者的会话
   允许发送。在这种情况下，会话带宽参数为
   个别发送者带宽的乘积乘以个数
   参与者，RTCP带宽为5％。

   在这些部分中给出了算法操作的细节
   跟随。  附录A.7给出了一个示例实现。



Schulzrinne等人 标准轨迹[第27页]
 
RFC 3550                           RTP July 2003


6.2.1维护会议成员人数

   RTCP数据包间隔的计算取决于估计
   参加会议的网站数量。新的网站是
   当他们被听到时加入计数，并且每个应该都有一个条目
   在由SSRC或CSRC标识符索引的表中创建（见
   第8.2节）来跟踪他们。可以考虑新的条目
   在多个包含新的SSRC的数据包已经存在之前无效
   收到（见附录A.1），或直到包含SDES RTCP包
   已收到该SSRC的CNAME。可以从中删除条目
   表中有一个RTCP BYE数据包与相应的SSRC
   标识符被接收，除了一些分类数据包可能
   在BYE之后到达，并重新创建条目。代替，
   条目应该被标记为已经接收到BYE然后被删除
   经过适当的延误。

   参与者可以将另一个站点标记为不活动，或者如果还没有，则将其删除
   如果没有收到少量的RTP或RTCP数据包，则有效
   的RTCP报告间隔（5被推荐）。这提供了一些
   对丢包的鲁棒性。所有网站必须具有相同的值
   对于这个乘数，必须计算大致相同的值
   RTCP报告间隔，以使此超时正常工作。
   因此，该乘法器应该针对特定的配置文件来修复。

   对于有大量参与者的会议，可能是
   维护一个表以存储SSRC标识符和
   所有的状态信息。实施可以使用SSRC
   取样，如[ 21 ]所述，以减少存储要求。
   实现可以使用类似的任何其他算法
   性能。一个关键的要求是任何算法考虑
   尽管如此，不应该大大低估了群体规模
   估计可能高估

6.3 RTCP包发送和接收规则

   有关如何发送的规则，以及收到RTCP时该怎么办
   数据包在这里概述。允许操作的实现
   组播环境或多点单播环境必须满足
   在需求6.2节。这样的一个实现可以使用
   本节中定义的算法以满足这些要求，或者可能
   只要提供等效或更好的使用其他算法
   性能。一个限于双方的实施
   单播操作应该仍然使用RTCP的随机化
   传输间隔以避免多次同步的意外
   实例在同一环境中运行，但可以省略“定时器”
   重新考虑“和”反向重新考虑“算法
   6.3.3,6.3.6和6.3.7。




Schulzrinne等人 标准履历[第28页]
 
RFC 3550                           RTP July 2003


   要执行这些规则，会话参与者必须维护几个
   状态：

   tp：最后一次传输RTCP数据包;

   tc：当前时间;

   tn：RTCP分组的下一个调度传输时间;

   pm会员：在时间tn的会议成员的估计数
      最后重新计算

   成员：最新的会议次数估计
      成员;

   发件人：最新的发件人数量估计
      会议;

   rtcp_bw：目标RTCP带宽，即总带宽
      这将被本次会议的所有成员用于RTCP数据包，
      每秒八位字节。这将是一个特定的分数
      “会话带宽”参数提供给应用程序
      启动。

   we_sent：如果应用程序已发送数据，则标志为true
      因为第二次RTCP报告被传输。

   avg_rtcp_size：平均复合RTCP数据包大小（以字节为单位）
      在此参与者发送和接收的所有RTCP数据包上。该
      大小包括下层传输和网络协议头
      （例如，UDP和IP），如第6.2节所述。

   initial：如果应用程序尚未发送，则为true
      一个RTCP包。

   这些规则中的许多使用“计算的间隔”之间
   分组传输。该间隔如下所述
   部分。

6.3.1计算RTCP传输间隔

   为了保持可扩展性，来自a的数据包之间的平均间隔
   会话参与者应该按组大小进行扩展。这个间隔
   称为计算间隔。它是通过组合a获得的
   上述状态数。计算
   间隔T然后如下确定：





Schulzrinne等人 标准履历[第29页]
 
RFC 3550                           RTP July 2003


   如果发件人的数量小于或等于25％
      会员（会员），间隔取决于是否
      参与者是发件人（不是基于we_sent的值）。
      如果参与者是发件人（we_sent true），则常数C是
      设置为平均RTCP包大小（avg_rtcp_size）除以25％
      的RTCP带宽（rtcp_bw），常数n设置为
      发件人人数 如果we_sent不为真，则设定常数C
      到平均RTCP分组大小除以RTCP的75％
      带宽。常数n设置为接收器的数量
      （会员 - 发件人）。如果发件人的数量大于
      25％，发件人和接收者一起处理。常数C
      被设置为平均RTCP分组大小除以总RTCP
      带宽和n设置为总成员数。就像声明的那样
      在6.2节中，RTP配置文件可以指定RTCP带宽
      可以由两个单独的参数明确定义（称为S
      和R）对于那些作为发件人和那些的人
      不是。在这种情况下，25％的分数变为S /（S + R）和
      75％馏分成为R /（S + R）。注意，如果R为零，则
      发件人的百分比永远不会大于S /（S + R），而
      实施必须避免除以零。

   2.如果参与者尚未发送RTCP数据包（变量
      初始化为真），常数Tmin设置为2.5秒，否则
      设置为5秒。

   确定性计算间隔Td设定为max（Tmin，n * C）。

   计算出的间隔T被设定为均匀分布的数字
      在确定性计算间隔的0.5到1.5倍之间。

   所得到的T值除以e-3/2 = 1.21828进行补偿
      因为定时器重新考虑算法收敛
      RTCP带宽的值低于预期平均值。

   这个过程导致一个间隔是随机的，但是哪个是
   平均值，给发送者和至少25％的RTCP带宽
   休息到接收器。如果发件人构成四分之一以上
   的成员资格，这个过程将带宽平均分配
   所有参与者，平均。

6.3.2初始化

   加入会话后，参与者将tp初始化为0，tc
   0，发件人为0，pmembers为1，成员为1，we_sent为false，
   rtcp_bw到会话带宽的指定分数，初始值
   为true，avg_rtcp_size为第一个RTCP的可能大小
   应用程序稍后构建的数据包。计算
   然后计算间隔T，并且调度第一分组



Schulzrinne等人 标准履历[第30页]
 
RFC 3550                           RTP July 2003


   时间tn = T。这意味着设置了传输定时器
   请注意，应用程序可以使用任何所需的
   实现这个定时器的方法。

   参与者将自己的SSRC添加到成员表中。

6.3.3接收RTP或非BYE RTCP报文

   当从SSRC的参与者接收到RTP或RTCP数据包时
   不在成员表中，SSRC被添加到表中，而
   参与者被验证后，会更新会员的价值
   如第6.2.1节所述。对于每个都进行相同的处理
   CSRC在经过验证的RTP数据包中。

   当从SSRC没有的参与者接收到RTP数据包时
   在发送方表中，SSRC被添加到表中，并且该值
   为发件人更新。

   对于接收到的每个复合RTCP数据包，avg_rtcp_size的值为
   更新：

      avg_rtcp_size =（1/16）* packet_size +（15/16）* avg_rtcp_size

   其中packet_size是刚接收到的RTCP数据包的大小。

6.3.4接收RTCP BYE报文
对于RTCP BYE的情况，
   除了第6.3.7节所述
   要发送，如果接收到的分组是RTCP BYE分组，则
   对照成员表检查SSRC。如果存在，条目是
   从表中删除，并更新成员的值。该
   然后对发送方表检查SSRC。如果存在，则条目
   从表中删除，并更新发件人的值。

   此外，使RTCP包的传输速率更多
   适应组织成员变更，以下“反向”
   重新考虑“算法应该在BYE数据包时执行
   收到将成员减少到小于pmembers的值：

   o tn的值根据以下公式更新：

         tn = tc +（members / pmembers）*（tn-tc）

   o tp的值根据以下公式更新：

         tp = tc  - （members / pmembers）*（tc-tp）。





Schulzrinne等人 标准履历[第31页]
 
RFC 3550                           RTP July 2003


   o下一个RTCP数据包重新安排在时间tn进行传输，
      现在更早了。

   o pmembers的值设置成等于成员。

   该算法不会阻止组大小估计
   由于过早，短时间内不正确地下降到零
   超大会议大部分时间的同时离开
   有些仍然存在。该算法确实使估计返回到
   更正确的价值。这种情况是不寻常的，而且
   后果是充分无害的，认为这个问题
   只是次要关注。

6.3.5计时SSRC

   偶尔间隔，参加者必须检查是否有任何
   其他参与者超时。为此，参与者
   计算确定性（无随机化因子）
   接收机的计算间隔Td，即we_sent为false。
   任何其他尚未发送RTP或RTCP数据包的会话成员
   时间tc  -  MTd（M是超时乘数，默认为5）是
   时间到。这意味着其SSRC从成员列表中删除，
   并更新成员。对发件人进行类似的检查
   名单。发件人列表中没有发送RTP数据包的任何成员
   因为时间tc  -  2T（在最后两个RTCP报告间隔内）是
   从发件人列表中删除，更新发件人。

   如果任何成员超时，反向重新考虑算法
   应在6.3.4节中进行说明。

   参加者必须至少对每个RTCP进行一次此检查
   传输间隔。

6.3.6传输定时器到期

   当分组传输定时器到期时，参与者执行
   以下操作：

   o如第
      6.3.1 节所述计算传输间隔T ，包括随机化因子。

   o如果tp + T小于或等于tc，则RTCP分组为
      传输。tp设置为tc，则T的另一个值为
      如上一步计算，tn设置为tc + T
      传输定时器设置为在时间tn再次到期。如果tp + T
      大于tc，tn设置为tp + T。没有RTCP分组
      传输。发送定时器设置为在时间tn到期。




Schulzrinne等人 标准履历[第32页]
 
RFC 3550                           RTP July 2003


   o会员设置成员。

   如果发送RTCP数据包，则初始值设置为
   假。此外，更新avg_rtcp_size的值：

      avg_rtcp_size =（1/16）* packet_size +（15/16）* avg_rtcp_size

   其中packet_size是刚发送的RTCP数据包的大小。

6.3.7发送BYE数据包

   当参与者希望离开会话时，BYE数据包是
   传送给其他参与者通知事件。为了
   以避免在许多参与者离开时出现泛滥的BYE数据包
   系统中，如果参与者必须执行以下算法
   当参与者选择时，会员人数超过50人
   离开。该算法篡夺了成员变量的正常角色
   计数BYE数据包：

   o当参与者决定离开系统时，tp重置为
      tc，当前时间，成员和pmembers都初始化为1，
      初始设置为1，we_sent设置为false，发件人设置为0，
      并且avg_rtcp_size设置为复合BYE数据包的大小。
      计算出计算出的间隔T。那么BYE包就是
      计划时间tn = tc + T.

   o每次收到来自另一个参与者的BYE数据包时，
      无论该参与者是否成员加1
      存在于成员表中，并且SSRC采样处于
      使用，无论是否包括BYE SSRC
      在样品中。当其他RTCP数据包成员不会递增
      或RTP数据包被接收，但仅用于BYE数据包。同样的，
      仅对接收的BYE数据包更新avg_rtcp_size。发件人
      RTP数据包到达时未更新; 它仍然是0。

   o传输BYE数据包然后遵循规则
      如上所述传输一个常规RTCP数据包。

   这允许BYE数据包立即发送，但控制它们
   总带宽使用。在最坏的情况下，这可能会导致RTCP
   控制数据包使用正常带宽的两倍（10％） -  5％
   非BYE RTCP数据包，5％用于BYE。

   不想等待上述机制的参与者
   允许发送BYE包可以离开组
   发送一个BYE。该参与者最终将超时
   由其他小组成员。




Schulzrinne等人 标准轨迹[第33页]
 
RFC 3550                           RTP July 2003


   如果团体大小估计会员不到50岁
   参与者决定离开，参与者可以发送BYE数据包
   立即。或者，参与者可以选择执行
   以上BYE退避算法。

   在任一情况下，从未发送RTP或RTCP数据包的参与者
   离开组时不得发送BYE数据包。

6.3.8更新we_sent

   如果参与者发送了RTP，则变量we_sent包含true
   包最近，否则为false。这个决定是由
   使用与管理其他组件相同的机制
   参与者在发件人表中列出。如果参与者发送
   当we_sent为false时，RTP数据包将自身添加到发送方
   表并将we_sent设置为true。反向重新考虑第6.3.4节 
   描述的算法应该被执行到可能
   在发送SR报文之前减少延迟。每次另一个RTP
   分组被发送，保持该分组的传输时间
   在桌子里 然后应用正常的发送者超时算法
   参与者 - 如果一个RTP包未被传输
   时间tc  -  2T，参与者将自己从发送方表中删除，
   递减发送者数，并将we_sent设置为false。

6.3.9分配源描述带宽

   此规范定义了几个源描述（SDES）项
   除了强制性的CNAME项目，如NAME（个人名称）
   和EMAIL（电子邮件地址）。它还提供了一种定义新的方法
   应用程序特定的RTCP数据包类型。应用程序应该运动
   将控制带宽分配给此额外的警告
   信息，因为它会降低接收率
   报告和CNAME被发送，从而损害了性能
   协议。建议不超过20％的RTCP
   分配给单个参与者的带宽用于携带
   附加信息。而且，并不是全部
   SDES项目将包含在每个应用程序中。那些是
   包括应该根据带宽分配一小部分
   他们的效用。而不是动态地估计这些分数
   建议将百分比静态翻译成
   报告间隔根据项目的典型长度计数。

   例如，应用程序可能只被设计为仅发送CNAME，NAME
   和EMAIL，而不是任何其他。NAME可能要高得多
   优先于EMAIL，因为NAME将不断显示
   在应用程序的用户界面中，而EMAIL将被显示
   只有在要求的时候 在每个RTCP间隔，一个RR包和一个
   将发送具有CNAME项目的SDES数据包。对于一个小会议



Schulzrinne等人 标准轨迹[第34页]
 
RFC 3550                           RTP July 2003


   以最小间隔操作，即每5秒钟一次
   平均 每隔三秒（15秒），一个额外的项目会
   被包括在SDES包中。这将是八次
   成为NAME项目，每八分之一秒（2分钟）即可
   EMAIL项目。

   当多个应用程序使用交叉应用程序协同工作时
   通过每个参与者的公共CNAME绑定，例如在
   多媒体会议由每个媒体的RTP会话组成，
   可以仅在一个RTP会话中发送附加的SDES信息。该
   其他会话只会携带CNAME项。特别是这个
   方法应该应用于分层的多个会话
   编码方案（见第2.4节）。

6.4发件人和接收者报告

   RTP接收器使用RTCP报告提供接收质量反馈
   取决于是否可以采取两种形式之一的分组
   接收者也是发送者。唯一的区别在于
   发送方报告（SR）和接收方报告（RR）形式，除了数据包
   类型代码是发件人报告包含一个20字节的发件人
   信息部分供活动发送者使用。如果a。发出SR
   站点在发布后的间隔内发送了任何数据包
   上次报告或前一次报告，否则发布了“无线电规则”。

   SR和RR表单都包括零个或多个接收报告
   块，每个同步源一个
   接收方自上次报告以来已收到RTP数据包。
   不会向中国证监会出具报告
   名单。每个接收报告块提供有关数据的统计信息
   从该块中指出的特定源接收。自从
   最多31个接收报告块将适合SR或RR报文，
   在初始SR或RR之后，应该堆叠额外的RR数据包
   包需要包含所有来源的接收报告
   自上次报告以来的间隔期间听到。如果还有
   许多来源将所有必需的RR数据包装入一个组合
   RTCP数据包不超过网络路径的MTU，则只能使用
   将适合一个MTU的子集应该包含在每个MTU中
   间隔。子集应该被选择在多个循环中
   间隔，以便报告所有来源。

   接下来的章节定义了两个报告的格式
   如果应用程序需要，可以以特定于配置文件的方式扩展
   额外的反馈信息以及报告的使用方式。
   详细介绍了翻译和混音器的接收报告
   第7节。





Schulzrinne等人 标准履历[第35页]
 
RFC 3550                           RTP July 2003


6.4.1 SR：发送者报告RTCP数据包

        0 1 2 3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
标题| V = 2 | P | RC | PT = SR = 200 | 长度|
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | 发信人SSRC
       + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +
发件人| NTP时间戳，最重要的字|
信息+  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | NTP时间戳，最低有效字|
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | RTP时间戳
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | 发件人的包数|
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | 发件人的八位字节数|
       + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +
报告| SSRC_1（第一来源SSRC）|
block +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
  1 | 分数丢失| 累积丢包数|
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | 扩展最高序列号|
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | interarrival jitter |
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | 最后一个SR（LSR）|
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | 延迟自上次SR（DLSR）|
       + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +
报告| SSRC_2（第二来源SSRC）|
block +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
  2：...：
       + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +
       | 个人资料特定的扩展程序|
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   发送者报告包可能包含三个部分
   之后是第四个特定于配置文件的扩展部分。
   第一部分，标题是8个八位字节长。领域有
   以下含义：

   版本（V）：2位
      标识RTP的版本，这在RTCP数据包中是相同的
      如在RTP数据包中。本规范定义的版本
      是两（2）。




Schulzrinne等人 标准履历[第36页]
 
RFC 3550                           RTP July 2003


   填充（P）：1位
      如果填充位被设置，则该单独的RTCP分组包含
      一些额外的填充八位字节在结尾不属于它们
      控制信息，但包括在长度字段中。该
      填充的最后八位字节是多少个填充八位字节的计数
      应该被忽略，包括它本身（它将是一个倍数
      四）。一些加密算法可能需要填充
      固定块尺寸。在复合RTCP数据包中，仅填充
      因为复合数据包是一个单独数据包所需的
      对于9.1节中的方法，作为一个整体加密。因此，填充
      必须只添加到最后一个单独的数据包，如果填充
      被添加到该分组中，填充位必须仅在其上设置
      包。该惯例有助于描述头文件的有效性检查
      在附录A.2中，允许从一些早期检测数据包
      第一个错误地设置填充位的实现
      单个数据包，并将填充添加到最后一个数据包。

   接收报告计数（RC）：5位
      该包中包含的接收报告块的数量。一个
      零值有效。

   分组类型（PT）：8位
      包含常数200，将其标识为RTCP SR数据包。

   长度：16位
      这个RTCP包的长度在32位字减一，
      包括标题和任何填充。（一个的偏移量
      将一个有效长度置零，并避免可能的无限循环
      扫描复合RTCP数据包，同时计数32位字
      避免对4的倍数进行有效性检查）

   SSRC：32位
      这个的发起者的同步源标识符
      SR包。

   第二部分，发件人信息是20个八位字节长
   存在于每个发送者报告数据包中。它总结了数据
   来自该发送者的传输。这些字段具有以下内容
   含义：

   NTP时间戳：64位
      表示挂钟时间（见第4节当这份报告出现时，）
      发送，以便它可以与时间戳组合使用
      在其他接收者的接收报告中返回测量
      往返传播到这些接收机。接收者应该
      期望时间戳的测量精度可能是
      限制远远小于NTP时间戳的分辨率。该
      时间戳的测量不确定度没有被指示



Schulzrinne等人 标准轨迹[第37页]
 
RFC 3550                           RTP July 2003


      可能不知道。在没有wallclock概念的系统上
      时间，但确实有一些系统特定的时钟，如“系统”
      正常运行时间“，发送者可以使用该时钟作为参考来计算
      相对NTP时间戳。选择一个很重要的
      使用时钟，以便如果使用单独的实现来生成
      多媒体会话的各个流，全部
      实现将使用相同的时钟。直到2036年，
      相对和绝对时间戳将在高位不同
      （无效）比较会显示出很大的差异; 到那时一个
      希望不再需要相对时间戳。发件人
      没有wallclock或经过时间的概念可以设置NTP
      时间戳为零。

   RTP时间戳：32位
      与NTP时间戳（上）相同，但在
      相同的单位和与RTP相同的随机偏移量
      数据包中的时间戳。可以使用这种对应关系
      内网和媒体间同步的NTP
      时间戳是同步的，可以由媒体独立使用
      接收机估计标称RTP时钟频率。注意
      在大多数情况下，这个时间戳不会等于RTP
      任何相邻数据包中的时间戳。相反，它必须是
      使用相应的NTP时间戳计算
      RTP时间戳计数器和实时之间的关系为
      通过定期检查在a的时钟时间来维护
      采样瞬间

   发送方的数据包数：32位
      发送方发送的RTP数据包的总数
      自启动传输直到此SR数据包的时间
      产生。如果发件人更改，则应重置计数
      SSRC标识符

   发件人的八位字节数：32位
      有效载荷字节的总数（即不包括标题或
      填充）由发送者在RTP数据包中传输
      启动传输直到该SR数据包的时间
      产生。如果发件人更改，则应重置计数
      SSRC标识符 该字段可用于估计平均值
      有效载荷数据速率。

   第三部分包含零个或多个接收报告块
   取决于此发件人听到的其他来源的数量
   最后一份报告。每个接收报告块传达统计信息
   从单个同步源接收RTP数据包。
   收件人在源更改时不应过帐统计信息
   SSRC标识符由于碰撞。这些统计数据是：




Schulzrinne等人 标准履历[第38页]
 
RFC 3550                           RTP July 2003


   SSRC_n（源标识符）：32位
      这个信息的源的SSRC标识符
      接收报告块属性。

   分数丢失：8位
      源SSRC_n的RTP数据包的分数自
      以前的SR或RR包被发送，表示为固定点
      数字与二进制点在字段的左边缘。（那
      相当于乘以整数部分
      损失分数为256.）该分数定义为数
      的数据包丢失除以预期的数据包数，as
      在下一段中定义。一个实现显示在
      附录A.3。如果由于重复的损失是负的，那么
      分数损失设置为零。请注意，接收器不能告诉
      最后收到的数据包是否丢失，
      不会有一个来源发出接收报告块
      如果在最后一次报告期间发送了源的所有数据包
      间隔已经丢失。

   累积丢包数：24位
      源SSRC_n的RTP数据包总数
      自接待开始以来一直失去。这个数字是
      定义为预期的数据包数量少
      数据包实际接收，其中接收到数据包的数量
      包括任何迟到或重复的。因此，数据包
      到达迟到不算丢失，损失可能为负数
      如果有重复。预期的数据包数
      定义为接收的扩展的最后序列号，as
      接下来定义的是接收到的初始序列号。这可能
      按附录A.3所示计算。

   扩展的最高序列号：32位
      低16位包含在其中接收的最高序列号
      源SSRC_n的RTP数据包，最重要16
      比特扩展该序列号与相应的计数
      序列号周期，可以根据
      算法在附录A.1中。请注意不同的接收机
      同一个会话将会生成不同的扩展名
      序列号，如果它们的起始时间显着不同。

   interarrival抖动：32位
      RTP数据包的统计方差的估计
      实时时间，以时间戳单位衡量，并表示为
      无符号整数。星际抖动J被定义为
      差值D in的平均偏差（平滑绝对值）
      接收机的分组间隔与一对发送方相比
      的数据包。如下面的等式所示，这相当于
      两个包的“相对传播时间”的差异;



Schulzrinne等人 标准轨迹[第39页]
 
RFC 3550                           RTP July 2003


      相对传输时间是数据包的RTP之间的差异
      时间戳和接收者的时钟在到达时，
      以相同的单位衡量。

      如果Si是来自分组i的RTP时间戳，并且Ri是时间
      到达分组i的RTP时间戳单位，然后到达两个分组
      i和j，D可以表示为

         D（i，j）=（Rj-Ri） - （Sj-Si）=（Rj-Sj） - （Ri-Si）

      差异抖动应该连续计算
      使用此数据包i从源SSRC_n接收
      该分组的差分D和先前的分组i-1按顺序
      （不一定按顺序），按照公式

         J（i）= J（i-1）+（| D（i-1，i）| -J（i-1））/ 16

      每当发出接收报告时，J的当前值为
      采样。

      抖动计算必须符合这里指定的公式
      以使配置文件独立的显示器有效
      来自不同实施的报告的解释。
      该算法是最优一阶估计器和增益
      参数1/16给出了良好的降噪比
      保持一个合理的收敛速度[ 22 ]。一个样品
      实施情况见附录A.8。见第6.4.4节的
      讨论变化的包持续时间和延迟的影响
      传输前。

   最后一个SR时间戳（LSR）：32位
      中间的32位在64位的NTP时间戳（如
      第4节）作为最近RTCP发件人报告的一部分收到
      （SR）数据包。如果尚未收到SR，
      该字段设置为零。

   自上次SR（DLSR）以来的延迟：32位
      延迟，以1/65536秒为单位表示
      从源SSRC_n接收最后一个SR数据包并发送
      接收报告块。如果尚未收到SR数据包
      从SSRC_n，DLSR字段设置为零。

      让SSRC_r表示发送此接收方报告的接收方。
      源SSRC_n可以计算往返传播延迟
      SSRC_r通过记录该接收报告块的时间A
      接收。它计算出总共往返时间A-LSR
      最后一个SR时间戳（LSR）字段，然后减去该字段
      将往返传播延迟作为（A-LSR-DLSR）。这个



Schulzrinne等人 标准履历[第40页]
 
RFC 3550                           RTP July 2003


      如图1所示。时间以十六进制显示
      32位字段的表示和等效的浮点数，
      点十进制表示。冒号表示一个32位字段
      分为16位整数部分和16位分数部分。

      这可以用作距离聚类的近似度量
      接收机，虽然一些链路有非常不对称的延迟。

   [10 Nov 1995 11：33：25.125 UTC] [10 Nov 1995 11：33：36.5 UTC]
   n SR（n）A = b710：8000（46864.500 s）
   -------------------------------------------------- -------------->
                      v ^
   ntp_sec = 0xb44db705 v ^ dlsr = 0x0005：4000（5.250s）
   ntp_frac = 0x20000000 v ^ lsr = 0xb705：2000（46853.125s）
     （3024992005.125 s）v ^
   rv ^ RR（n）
   -------------------------------------------------- -------------->
                          | <-DLSR-> |
                           （5.250 s）

   A 0xb710：8000（46864.500 s）
   DLSR -0x0005：4000（5.250 s）
   LSR -0xb705：2000（46853.125 s）
   -------------------------------
   延迟0x0006：2000（6.125秒）

           图2：往返时间​​计算示例
























Schulzrinne等人 标准轨迹[第41页]
 
RFC 3550                           RTP July 2003


6.4.2 RR：接收器报告RTCP包

        0 1 2 3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
标题| V = 2 | P | RC | PT = RR = 201 | 长度|
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | 数据包发送方的SSRC
       + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +
报告| SSRC_1（第一来源SSRC）|
block +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
  1 | 分数丢失| 累积丢包数|
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | 扩展最高序列号|
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | interarrival jitter |
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | 最后一个SR（LSR）|
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | 延迟自上次SR（DLSR）|
       + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +
报告| SSRC_2（第二来源SSRC）|
block +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
  2：...：
       + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +
       | 个人资料特定的扩展程序|
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   接收器报告（RR）报文的格式与
   SR包除了包类型字段包含常量
   201和发送者信息的五个字被省略（这些都是
   NTP和RTP时间戳和发送者的数据包和八位字节计数）。
   其余字段与SR数据包的含义相同。

   一个空的RR包（RC = 0）必须放在一个复合的头上
   当没有数据传输或接收时，RTCP包
   报告。

6.4.3扩展发件人和接收者报告

   配置文件应定义配置文件特定的发件人扩展
   报告和接收者报告如果有其他信息
   需要定期报告发送者或接收者。这个
   应该优先使用方法来定义另一个RTCP数据包
   因为它需要较少的开销：

   o分组中的八位字节较少（无RTCP头或SSRC字段）;




Schulzrinne等人 标准轨迹[第42页]
 
RFC 3550                           RTP July 2003


   o更简单快速的解析，因为运行的应用程序
      配置文件将被编程为始终期待扩展字段
      在接待报告后的直接访问位置。

   扩展名是发件人或接收者报告中的第四部分
   接收报告结束后的数据包阻塞，如果
   任何。如果需要额外的发件人信息，那么对于发件人
   报告将首先列入扩展部分，但是
   接收者报告不存在。如果有关的信息
   接收器将被包括在内，该数据应该被构造为一个
   阵列阵列与现有的阵列接收报告并行
   块; 也就是说，RC的数量将由RC指示
   领域。

6.4.4分析发件人和接收者报告

   预计接收质量反馈将不会有用
   仅用于发送方，也可用于其他接收方和第三方
   显示器。发送者可以基于该修改来修改其传输
   反馈; 接收者可以确定问题是否是本地的，
   区域或全球; 网络管理员可能会使用个人资料
   只接收RTCP数据包而不是相应的监视器
   RTP数据包来评估其网络的性能
   组播分配。

   累积计数用于发送者信息和
   接收机报告块，以便可以计算差异
   任何两个报告都可以在短时间内进行测量
   并为失去报告提供弹性。该
   收到的最后两份报告之间的差异可以用于
   估计最近的分销质量。NTP时间戳
   包括在内，从而可以根据这些差异来计算费率
   在两个报告之间的间隔。因为那个时间戳是
   独立于数据编码的时钟速率，这是可能的
   实现编码和轮廓无关的质量监视器。

   示例计算是间隔内的丢包率
   两个接待报告之间。累积的差异
   丢失的数据包数量在该间隔期间丢失数量。
   接收的扩展的最后序列号的差异给出
   在间隔期间预期的数据包数。的比例
   这两个是间隔内的丢包率。这个比例
   如果两个报告是相等的，则应该等于分数丢失字段
   连续，但否则可能没有。每秒的损失率可以
   通过将损失分数除以NTP的差异来获得
   时间戳，以秒表示。收到的报文数量是
   预期的包数减去丢失的数量。的数量




Schulzrinne等人 标准履历[第43页]
 
RFC 3550                           RTP July 2003


   预期的包也可用于判断统计有效性
   的任何损失估计。例如，丢失的5个数据包中有1个具有一个
   低于1000的显着性。

   从发件人信息，第三方监视器可以计算
   平均有效载荷数据速率和平均包速率
   间隔而不接收数据。以两者的比例
   给出平均有效载荷大小。如果可以假定该包
   丢包与数据包大小无关，则数据包数量
   由特定接收机接收到的平均有效载荷大小（或
   相应的分组大小）给出了表观吞吐量
   可用于该接收器。

   除了允许长期分组的累积计数
   损失测量使用报告之间的差异，分数
   失去的领域从单一报告中提供短期测量。
   随着会议的大小足够大，这变得更加重要
   该接收状态信息可能不会被保留给所有接收机
   或报告之间的间隔变得足够长，只有一个
   报告可能已经从特定接收者收到。

   差距抖动场提供了第二个短期测量
   网络拥塞 数据包丢失跟踪持续拥塞
   抖动测量跟踪瞬态拥塞。抖动测量
   可能会在导致数据包丢失之前指示拥塞。该
   interarrival抖动场只是抖动的一个快照
   报告的时间，而不是定量地采取。
   相反，它是为了比较来自多个报告
   一个接收器随着时间的推移或从多个接收器，例如，在一个
   单网，同时。允许比较
   接收机，重要的是根据抖动进行计算
   所有接收器的公式相同。

   因为抖动计算是基于RTP时间戳的
   表示分组中的第一数据被采样的时刻，
   该采样时刻与时间之间延迟的任何变化
   传输的数据包将影响所产生的抖动
   计算。音频数据包会发生延迟的这种变化
   不同的时间。视频编码也会发生，因为
   时间戳对于一帧的所有数据包是相同的，但是那些
   数据包并非全部同时传输。变化
   延迟直到传输确实降低抖动的准确性
   计算作为衡量网络行为的本身，
   但是考虑到接收缓冲区是合适的
   必须适应它。当抖动计算用作a
   比较测量，（常数）分量由于变化
   延迟直到传输减去，以便改变




Schulzrinne等人 标准轨迹[第44页]
 
RFC 3550                           RTP July 2003


   然后可以观察到网络抖动分量，除非它是相对的
   小。如果变化很小，那么很可能是
   无关紧要的。

6.5 SDES：源描述RTCP数据包

        0 1 2 3
        0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
       +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
标题| V = 2 | P | SC | PT = SDES = 202 | 长度|
       + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +
块| SSRC / CSRC_1 |
  1 +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | SDES项目|
       | ... |
       + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +
块| SSRC / CSRC_2 |
  2 +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
       | SDES项目|
       | ... |
       + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +

   SDES数据包是一个由标题组成的三级结构，
   零个或多个块，每个块由描述的项目组成
   在该块中识别出来的源。描述项目
   单独在后续部分。

   版本（V），填充（P），长度：
      如SR包所述（参见第6.4.1节）。

   分组类型（PT）：8位
      包含常数202以将其识别为RTCP SDES分组。

   源计数（SC）：5位
      这个SDES包中包含的SSRC / CSRC块的数量。一个
      零值是有效的，但没有用。

   每个块由一个SSRC / CSRC标识符和一个列表组成
   零个或多个项目，载有关于SSRC /中国证监会的信息。
   每个块从32位边界开始。每个项目由8-
   位类型字段，描述长度的8位八位字节计数
   文本（因此，不包括这个两个八位字节标题）和文本
   本身。请注意，文本不能超过255个八位字节，但是
   这与需要限制RTCP带宽消耗一致。







Schulzrinne等人 标准履历[第45页]
 
RFC 3550                           RTP July 2003


   文本根据RFC 
   2279 [ 5 ] 中规定的UTF-8编码进行编码。US-ASCII是该编码的一个子集，不需要
   附加编码。多字节编码的存在是
   通过将字符的最高有效位设置为a来指示
   价值一。

   项目是连续的，即项目没有单独填充到
   32位边界。文本不是空终止的，
   八位字节编码包括空字节。每个块中的项目列表
   必须由一个或多个空字节终止，第一个是八位字节
   解释为项目类型为零以表示列表的结尾。
   没有长度的八位位组遵循空项目类型八位字节，但额外的空值
   如果需要，必须包括八位字节，直到下一个32位
   边界。请注意，此填充与指示的填充是分开的
   RTCP头中的P位。零个零件的零件（四个零
   八位字节）有效但没有用。

   终端系统发送一个包含自己的源的SDES数据包
   标识符（与固定RTP报头中的SSRC相同）。搅拌机
   发送一个包含每个贡献源的块的SDES数据包
   从中收到SDES信息，或多次完成
   以上格式的SDES数据包如果有超过31个这样的
   来源（见第7节）。

   下面将介绍当前定义的SDES项目。
   只有CNAME项是强制性的。这里显示的一些项目可能是
   仅对特定配置文件有用，但项目类型全部为
   从一个共同的空间分配，以促进共享使用和简化
   个人资料独立的应用程序。附加项目可以在其中定义
   通过使用IANA注册类型号来配置文件
   第15节。

6.5.1 CNAME：规范端点标识符SDES项目

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | CNAME = 1 | 长度| 用户名和域名...
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   CNAME标识符具有以下属性：

   o因为随机分配的SSRC标识符可能会改变，如果a
      冲突被发现或程序重新启动，CNAME
      必须包含项目以提供SSRC的绑定
      标识符到源（发送方或接收方）的标识符
      这一直保持不变。




Schulzrinne等人 标准履历[第46页]
 
RFC 3550                           RTP July 2003


   o像SSRC标识符一样，CNAME标识符也应该是
      在一个RTP会话中的所有参与者中是唯一的。

   o提供一个使用的多个媒体工具的绑定
      参与一组相关的RTP会话，CNAME应该是
      固定为该参与者。

   o为了方便第三方监控，CNAME应该是合适的
      一个程序或一个人定位源。

   因此，CNAME应该算法而不是
   尽可能手动输入。为了满足这些要求，
   应使用以下格式，除非配置文件指定
   备用语法或语义。CNAME项目应该有格式
   “user @ host”或“host”，如果用户名不可用，
   用户系统。对于这两种格式，“主机”是完全限定的
   来自实时数据的主机的域名，
   根据RFC 1034 [ 6 ]，RFC 1035 
   [ 7 ]和RFC 1123 [ 2 ] 第2.1节规定的规则格式化。或标准ASCII
   在所使用的接口上表示主机的数字地址
   用于RTP通信。例如，标准ASCII
   IP版本4地址的表示也是“点分十进制”，也是
   称为虚线四分之一，对于IP版本6，地址是文本的
   表示为以冒号分隔的十六进制数字组（与
   变体如RFC 3513 [ 23 ] 所详述）。其他地址类型是
   期望具有相互独特的ASCII表示。该
   完全合格的域名对于人类观察者来说更为方便
   并且可以避免需要另外发送NAME项目，但也可能是
   困难或不可能在一些操作中可靠地获得
   环境。可能在这种环境中运行的应用程序
   应该使用地址的ASCII表示。

   例如“doe@sleepy.example.com”，“doe@192.0.2.89”或
   “doe @ 2201：056D :: 112E：144A：1E24”用于多用户系统。在系统上
   没有用户名，示例将是“sleepy.example.com”，
   “192.0.2.89”或“2201：056D :: 112E：144A：1E24”。

   用户名应该是一个表单，一个程序，如“手指”或
   “talk”可以使用，即它通常是登录名而不是
   个人名字 主机名不一定相同
   一个在参与者的电子邮件地址。

   此语法不会为每个源提供唯一的标识符
   应用程序允许用户从一个生成多个源
   主办。这样的一个应用将不得不依靠SSRC进一步
   识别源或该应用程序的配置文件
   指定CNAME标识符的附加语法。




Schulzrinne等人 标准轨迹[第47页]
 
RFC 3550                           RTP July 2003


   如果每个应用程序独立地创建其CNAME，则生成
   CNAME可能与提供绑定所需的不同
   跨多个媒体工具属于一组参与者
   相关RTP会话。如果需要跨媒体绑定，可能是
   每个工具的CNAME需要外部配置
   协调工具的价值相同。

   应用程序编写者应注意私网地址
   诸如RFC 1918 [ 24 ]中提出的Net-10分配的分配
   可能会创建不是全局唯一的网络地址。这个
   将导致非唯一的CNAME如果主机与私人地址和
   没有直接的IP连接到公共互联网有他们的RTP
   数据包通过RTP级转发到公共互联网
   翻译。（另见RFC 1627 [ 25 ]）。为了处理这种情况，
   应用程序可能提供配置唯一CNAME的方法，但是
   翻译人员负责翻译私人CNAME
   如果需要保留私人地址，公开地址
   不被暴露。

6.5.2名称：用户名SDES项目

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | NAME = 2 | 长度| 源的通用名称...
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   这是用来形容来源的真实姓名，例如“John Doe，
   位回收器“，它可能是用户希望的任何形式
   会议等应用程序，这种形式的名称可能是最多的
   希望在参与者列表中显示，因此可能是
   最常发送CNAME以外的其他项目。个人资料可能
   确定优先事项。NAME值将保留
   至少在会话期间不变。它不应该是
   在会议的所有参与者中依然是独一无二的。

6.5.3电子邮件：电子邮件地址SDES项目

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | EMAIL = 3 | 长度| 源的电子邮件地址...
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   电子邮件地址根据RFC 2822 [ 9 ]进行格式化
   例如“John.Doe@example.com”。预计EMAIL值
   在会话期间保持不变。




Schulzrinne等人 标准轨迹[第48页]
 
RFC 3550                           RTP July 2003


6.5.4电话：电话号码SDES项目

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | PHONE = 4 | 长度| 电话号码来源...
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   电话号码应使用加号替换格式
   国际接入码。例如，“+1 908 555 1212”for a
   在美国的数字。

6.5.5 LOC：地理位置SDES项目

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | LOC = 5 | 长度| 网站的地理位置...
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   根据应用，不同的细节是
   适合此项目。对于会议应用程序，一个字符串
   像“新泽西州的默里山”可能就足够了，而对于一个
   活动徽章系统，如“2A244室，AT＆T BL MH”的字符串可能是
   适当。详细程度由执行而定
   和/或用户，但格式和内容可能由配置文件规定。
   LOC值预计在a的持续时间内保持不变
   会话，移动主机除外。

6.5.6工具：应用程序或工具名称SDES项目

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | 工具= 6 | 长度|名称/版本的源应用程序。...
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   一个字符串，给出应用程序的名称和可能的版本
   生成流，例如“videotool 1.2”。此信息可能
   对于调试目的有用，并且与Mailer类似
   邮件系统版本的SMTP标头。预计工具值
   在会议期间保持不变。









Schulzrinne等人 标准轨迹[第49页]
 
RFC 3550                           RTP July 2003


6.5.7注意：通知/状态SDES项目

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | 注= 7 | 长度| 注意源...
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   为此项目提出以下语义，但这些或
   其他语义可以由配置文件显式定义。笔记
   项目用于描述当前状态的瞬态消息
   的来源，例如“在电话上，不能说话”。或者，在一个
   研讨会上，这个项目可能用来表达话题的标题。它
   应该仅用于携带特殊信息，不应该
   被所有参与者常规地包括在内，因为这会减慢
   降低了接收报告和CNAME的发送速率
   削弱了协议的性能。特别是它应该是
   不作为项目包含在用户的配置文件中
   自动生成，如在一个报价当天。

   由于NOTE项目在活动时可能很重要，
   其他非CNAME项目（如NAME）的传输率
   可能会减少，以便NOTE项可以占用RTCP的那部分
   带宽。当瞬态消息变为无效时，注意
   项目应该继续传播几次
   重复率，但用一串长度为零的信号
   接收器。但是，接收机也应该考虑NOTE项目
   如果没有收到一小段重复次数，则不活动
   速率，或者20-30 RTCP间隔。

6.5.8 PRIV：私人扩展SDES项目

     0 1 2 3
     0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
    +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
    | PRIV = 8 | 长度| 前缀长度|前缀字符串...
    +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
    ... | 值字符串...
    +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   此项目用于定义实验或应用程序特定的SDES
   扩展。该项目包含一个由长度字符串组成的前缀
   对，后跟填充项目剩余部分的值字符串
   并携带所需信息。前缀长度字段为8
   位长 前缀字符串是由人员定义的名称
   PRIV项目对于其他PRIV项目而言是独一无二的
   应用程序可能会收到。应用程序创建者可能会选择
   如果使用应用程序名称加上附加的子类型标识



Schulzrinne等人 标准履历[第50页]
 
RFC 3550                           RTP July 2003


   需要。或者，推荐其他人选择一个名字
   基于他们所代表的实体，然后协调使用
   该实体内的名称。

   请注意，该前缀消耗项目总数中的一些空间
   长度为255个八位字节，因此前缀应保持为短
   可能。这个设施和受限的RTCP带宽应该是
   不要过载; 它不是要满足所有的控制
   所有应用的通信要求。

   SDES PRIV前缀不会被IANA注册。如果某种形式
   PRIV项目证明是一般用途，它应该是
   分配了IANA注册的常规SDES项目类型，以便不会
   前缀是必需的。这简化了使用并增加了传输
   效率。

6.6 BYE：再见RTCP包

       0 1 2 3
       0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
      +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
      | V = 2 | P | SC | PT = BYE = 203 | 长度|
      +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
      | 中国证监会
      +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
      ：...：
      + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = + = +
（opt）| 长度| 离开的原因 ...
      +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   BYE包指示一个或多个源不再
   活性。

   版本（V），填充（P），长度：
      如SR包所述（参见第6.4.1节）。

   分组类型（PT）：8位
      包含常数203，将其识别为RTCP BYE数据包。

   源计数（SC）：5位
      该BYE数据包中包含的SSRC / CSRC标识符的数量。
      计数值为零是有效的，但没有用。

   指定何时发送BYE数据包的规则
   第6.3.7和8.2节。






Schulzrinne等人 标准履历[第51页]
 
RFC 3550                           RTP July 2003


   如果混音器接收到BYE数据包，则混音器应转发
   具有SSRC / CSRC标识符的BYE数据包不变。如果是搅拌机
   关闭，它应该发送一个BYE包列出所有贡献
   它处理的来源以及自己的SSRC标识符。（可选）
   BYE数据包可能包括一个8位八位字节计数，其次是许多
   指出离开原因的文字的八位字节，例如“相机”
   故障“或”检测到RTP循环“，字符串相同
   对于SDES描述的编码。如果字符串填满数据包
   到下一个32位边界，字符串不为空终止。如果
   不是，BYE数据包必须用空字节填充到下一个32位元组，
   位边界。这个填充与P表示的填充是分开的
   位在RTCP标头中。

6.7 APP：应用定义的RTCP包

    0 1 2 3
    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | V = 2 | P | 子类型| PT = APP = 204 | 长度|
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | 中国证监会
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | name（ASCII）|
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +
   | 应用依赖数据...
   +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  -  +  - +  -  +  -  +  -  +  -  +  -  +  -  +  -  +

   APP包用于作为新应用的实验用途
   并开发了新功能，无需分组类型值
   注册。应该忽略具有无法识别的名称的APP数据包。
   经过测试，如果更广泛的使用是合理的，建议
   每个APP数据包被重新定义，没有子类型和名称字段
   使用RTCP数据包类型向IANA注册。

   版本（V），填充（P），长度：
      如SR包所述（参见第6.4.1节）。

   子类型：5位
      可以用作子类型来允许一组APP数据包
      在一个唯一的名称下定义，或针对任何依赖于应用程序的
      数据。

   分组类型（PT）：8位
      包含将其识别为RTCP APP数据包的常数204。







Schulzrinne等人 标准轨迹[第52页]
 
RFC 3550                           RTP July 2003


   名称：4个八位字节
      由用户定义的一组APP包的名称
      对于本应用程序可能的其他APP数据包来说是唯一的
      接收。应用程序创建者可能会选择使用
      应用程序名称，然后协调子类型的分配
      值给想要定义新数据包类型的其他人
      应用。或者，建议其他人选择
      一个基于他们所代表的实体的名称，然后协调使用
      在该实体内的名称。该名称被解释为a
      四个ASCII字符的序列，大写和小写
      被视为不同的人物。

   应用依赖数据：可变长度
      应用程序相关数据可能出现或不会出现在APP数据包中。
      它由应用程序解释，而不是RTP本身。它必须
      是32位长的倍数。

7。RTP翻译器和混音器

   除了终端系统，RTP还支持“翻译”的概念，
   和“混合器”，可以被认为是“中间体”
   RTP级别。虽然这种支持增加了一些复杂性
   协议，这些功能的需要已经明确建立
   通过实验中的多播音视频应用
   互联网。第
   2.3 节中给出的翻译器和混音器的示例用法来自于防火墙的存在和低带宽
   连接，两者都可能保留。

7.1概述

   RTP转换器/混频器连接两个或更多传输级别
   “云”。通常，每个云由公共网络定义
   传输协议（例如，IP / UDP）加上多播地址和
   传输级目的端口或一对单播地址和
   端口。（网络级协议翻译器，如IP版本4到
   IP版本6，可能存在于云内不可见RTP
   系统可以用作多个RTP的转换器或混频器
   会议，但每个被认为是一个逻辑上分开的实体。

   为了避免在翻译器或混音器时产生回路
   必须遵守以下规则：

   o由翻译和混音器连接的每个云
      参加一个RTP会话必须与所有RTP会话不同
      这些参数中的至少一个（协议，地址，
      端口），或者必须在网络级别与其他端口隔离。





Schulzrinne等人 标准履历[第53页]
 
RFC 3550                           RTP July 2003


   o第一条规则的派生是不可以是多重的
      翻译器或混音器并行连接，除非有些
      安排他们分割要转发的源的集合。

   同样，所有的RTP端系统都可以通过一个或者
   更多RTP转换器或混音器共享相同的SSRC空间，
   所有这些终端系统中的SSRC标识符必须是唯一的。
   8.2节描述了碰撞解析算法
   SSRC标识符保持唯一，并检测到循环。

   翻译器和混音器可能有多种设计
   不同的用途和应用。一些例子是添加或
   删除加密，更改数据或底层的编码
   协议或多播地址与一个或多个地址之间的复制
   单播地址。翻译者和混音器之间的区别是
   翻译者通过不同的数据流
   来源分开，而混合器组合它们形成一个新的
   流：

   转换器：转发具有SSRC标识符的RTP数据包
      完整; 这使接收机有可能识别
      即使来自所有来源的数据包都通过，个人来源
      通过相同的翻译器和携带翻译的网络
      源地址。一些翻译将会通过
      数据不变，但其他人可能会更改数据的编码
      因此RTP数据有效载荷类型和时间戳。如果有多个数据
      数据包被重新编码为一个，反之亦然，译者必须
      为输出数据包分配新的序列号。损失
      输入分组流可能引起相应的间隙
      输出序列号。接收器无法检测到存在
      的翻译，除非他们通过某种其他方式知道什么有效载荷
      类型或传输地址由原始来源使用。

   混合器：从一个或多个接收RTP数据包流
      来源，可能会更改数据格式，将流合并在一起
      然后转发组合流。自从
      一般不会在多个输入源之间进行定时
      同步，混音器将进行时序调整
      流并为其组合流生成自己的时序，所以它
      是同步源。因此，转发的所有数据包
      必须使用混音器标记混音器自己的SSRC标识符。
      为了保留原始来源的身份
      有助于混合包，混音器应该插入它们
      SSRC标识符进入CSRC标识符列表后面的固定
      数据包的RTP头。混合器本身也是一个
      一些数据包的贡献来源应该明确地包含它
      在CSRC列表中拥有该数据包的SSRC标识符。




Schulzrinne等人 标准履历[第54页]
 
RFC 3550                           RTP July 2003


      对于某些应用，混合器可能是可以接受的
      确定中国证监会名单中的来源。但是，这介绍了
      无法检测涉及这些来源的环路的危险。

   混音器在翻译器上的优点，适用于诸如
   音频是输出带宽限制为一个来源
   即使输入端有多个源处于活动状态。这可能是
   对于低带宽链路很重要。缺点是
   输出端的接收器对此无任何控制
   来源通过或静音，除非有一些机制
   实现了对混音器的遥控。再生
   混音器的同步信息也意味着接收机不能
   做原始流的媒体间同步。一个多
   媒体搅拌机可以做到。

         [ E1 ] [E6]
          | |
    E1：17 | E6：15 |
          | | E6：15
          V M1：48（1,17）M1：48（1,17）V M1：48（1,17）
         （M1）-------------> <T1> -----------------> <T2> --------- -----> [E7]
          ^ ^ E4：47 ^ E4：47
     E2：1 | E4：47 | | M3：89（64,45）
          | | |
         [E2] [E4] M3：89（64,45）|
                                                  | 传说：
   [E3] --------->（M2）----------->（M3）------------ | [结束系统]
          E3：64M2：12（64）^（混合器）
                                   | E5：45 <译者>
                                   |
                                  [E5]来源：SSRC（CSRCs）
                                                ------------------->

   图3：具有终端系统，混音器和转换器的RTP网络示例

   混合器和翻译器的集合如图1所示。3到
   说明它们对SSRC和CSRC标识符的影响。在图中，
   终端系统显示为矩形（命名为E），翻译器为
   三角形（称为T）和混合器为椭圆形（称为M）。符号“M1：
   48（1,17）“表示由...标识的混合器M1的分组
   M1（随机）SSRC值为48和两个CSRC标识符，1和17，
   从E1和E2的分组的SSRC标识符复制。

7.2翻译器中的 RTCP处理

   除了转发数据包，也许是修改的翻译器
   混频器也必须处理RTCP数据包。在很多情况下，他们会的
   分离从终端系统接收的复合RTCP数据包



Schulzrinne等人 标准轨迹[第55页]
 
RFC 3550                           RTP July 2003


   聚合SDES信息并修改SR或RR数据包。
   该信息的重传可能由数据包触发
   到达或由翻译器或混频器的RTCP间隔定时器
   本身。

   不修改数据包的翻译器，例如一个
   这只是在多播地址和单播之间复制
   地址，也可以简单地转发未修改的RTCP数据包。一个
   翻译器必须以某种方式转换有效载荷
   SR和RR信息中的相应变换使其成为可能
   仍然反映了数据和接收的特点
   质量。这些翻译者不得简单地转发RTCP数据包。在
   一般来说，翻译器不应该聚合SR和RR数据包
   不同的来源成一个数据包，因为这将减少
   基于LSR的传播延迟测量的精度
   DLSR字段。

   SR发件人信息：翻译器不生成自己的
      发送方信息，但转发从一个收到的SR数据包
      云到别人 SSRC保持原样，但发送方
      如果翻译需要，信息必须修改。如果一个
      翻译者更改数据编码，它必须更改“发件人”
      字节计数“字段，如果还将多个数据包组合在一起
      一个输出数据包，它必须更改“发送方的数据包数”
      领域。如果它改变时间戳频率，它必须改变
      SR包中的“RTP时间戳”字段。

   SR / RR接收报告块：转换器转发接收
      从一个云收到的报告给其他云。请注意这些
      沿与数据相反的方向流动。剩下SSRC
      完整。如果翻译器将几个数据包组合成一个
      输出数据包，因此更改序列号，它必须
      对丢包字段进行逆操作
      “延长最后序列号”字段。这可能很复杂。在
      极端的情况下，可能没有什么有意义的方式来翻译
      接待报告，所以翻译者可以不经过接待
      根据自己的招待会报告或综合报告。
      一般规则是对某一特定事情做出有意义的事情
      翻译。

      翻译者不需要自己的SSRC标识符，但是
      可以选择分配一个用于发送报告的目的
      关于它收到了什么 这些将被发送给所有的
      连接云，每个对应的翻译
      数据流发送到那个云，因为接收报告是
      通常组播到所有参与者。





Schulzrinne等人 标准履历[第56页]
 
RFC 3550                           RTP July 2003


   SDES：翻译者通常向前而不改变SDES
      他们从一个云到另一个云的信息，但是可能，
      例如，决定如果过滤非CNAME SDES信息
      带宽有限。CNAME必须转发才能允许SSRC
      标识符碰撞检测工作。翻译者
      生成自己的RR数据包必须发送SDES CNAME信息
      关于自己到发送这些RR数据包的相同的云。

   BYE：转换器转发BYE报文不变。翻译者
      即将停止转发数据包应该发送一个BYE数据包
      到包含所有SSRC标识符的每个连接云
      以前被转发到该云，包括
      翻译者自己的SSRC标识符，如果发送自己的报告。

   APP：转换器转发APP数据包不变。

7.3混频器中的RTCP处理

   由于混音器产生自己的新的数据流，所以它不会
   完全通过SR或RR数据包，而是生成新的
   双方的信息。

   SR发送者信息：混合器不通过发送方
      信息来源，因为它的特点
      的源流在混合中丢失。作为同步
      源，混合器应该生成自己的带有发送方的SR数据包
      关于混合数据流的信息并将它们发送到同一数据流中
      方向作为混合流。

   SR / RR接收报告块：混音器产生自己的
      接收每个云中的源的报告，并将其发送出去
      只有到同一个云。它不得发送这些接收报告
      到其他云，不得转发接收报告
      一个云到别人，因为源不会是SSRC
      那里（只有CSRCs）。

   SDES：混频器通常在不改变SDES的情况下前进
      他们从一个云到另一个云的信息，但是可能，
      例如，决定如果过滤非CNAME SDES信息
      带宽有限。CNAME必须转发才能允许SSRC
      标识符碰撞检测工作。（中国证监会的标识
      由混音器生成的列表可能与SSRC标识符相冲突
      由终端系统产生的）混合器必须发送SDES CNAME
      关于自己的信息到发送SR或RR的同一个云
      数据包。






Schulzrinne等人 标准履历[第57页]
 
RFC 3550                           RTP July 2003


      由于混频器不转发SR或RR数据包，它们通常是这样
      从复合RTCP数据包中提取SDES数据包。至
      最小化开销，可以聚合SDES数据包的块
      变成单个SDES分组，然后将其堆叠在SR或RR上
      分组源自混频器。聚合SDES的混合器
      数据包将使用比单个源更多的RTCP带宽
      因为复合数据包会更长，而是这样
      因为混音器代表多个来源。
      类似地，一个混合器原样通过SDES数据包
      接收到的RTCP报文将会高于该报文
      单源速率，但再次是从数据包是正确的
      来自多个来源。RTCP分组速率可能不同
      在搅拌机的每一侧。

      没有插入CSRC标识符的混音器也可以避免
      转发SDES CNAME。在这种情况下，SSRC标识符
      两个云中的空间是独立的。如前面提到的，
      这种操作模式会产生循环不可能的危险
      检测。

   BYE：混音器必须转发BYE数据包。一个即将到来的混音器
      停止转发数据包应该向每个发送一个BYE数据包
      包含所有SSRC标识符的连接云
      以前被转发到该云，包括混音器
      自己的SSRC标识符如果发送自己的报告。

   APP：混合器处理APP数据包是特定于应用程序的。

7.4级联搅拌机

   RTP会话可能涉及混合器和转换器的集合
   如图1所示。3.如果两个混合器是级联的，如M2和M3
   该图，由混合器接收的分组可能已经混合
   并且可以包括具有多个标识符的CSRC列表。第二
   混合器应该使用该构建CSRC列表
   来自已混合输入数据包和SSRC的CSRC标识符
   来自未混合输入数据包的标识符。输出中显示
   来自混合器M3的电弧标示为M3：89（64,45）。在这种情况下
   没有级联的混合器，如果所得到的CSRC列表有更多
   超过15个标识符，其余部分不能包括在内。











Schulzrinne等人 标准轨迹[第58页]
 
RFC 3550                           RTP July 2003


8。SSRC标识符分配和使用

   RTP报头和各种字段中携带的SSRC标识符
   的RTCP数据包是一个随机的32位数
   在RTP会话中具有全局唯一性。数字至关重要
   请小心选择，以使参与者在同一网络或
   同时开始不太可能选择相同的数字。

   使用本地网络地址（如
   IPv4地址），因为地址可能不是
   独特。由于RTP转换器和混频器之间能够进行互操作
   多个网络具有不同的地址空间，分配
   两个空格内的地址模式可能会导致很多
   比随机分配发生更高的碰撞速度。

   在一个主机上运行的多个源也将冲突。

   通过简单地获取SSRC标识符也不足
   调用random（），而不是仔细初始化状态。一个
   如何生成随机标识符的示例
   附录A.6。

8.1碰撞的概率

   由于标识符是随机选择的，因此可能是两个或
   更多的来源将选择相同的数字。碰撞发生在
   所有来源同时启动时的最高概率
   一些会话管理自动触发的示例
   事件。如果N是源的数量和L的长度
   标识符（这里是32位），两个来源的概率
   独立选择相同的值可以近似为大N
   [ 26 ]为1-exp（-N ** 2/2 **（L + 1））。对于N = 1000，概率是
   大概10 **  -  4。

   典型的碰撞概率远低于最坏情况
   以上。当一个新的源加入一个RTP会话，其中所有的
   其他来源已经有唯一的标识符，概率为
   碰撞只是空间中使用的数字的一小部分。
   再次，如果N是源的数量和L的长度
   标识符，碰撞概率为N / 2 ** L。对于N = 1000，
   概率约为2 * 10 **  -  7。

   碰撞的机会进一步减少
   一个新的来源接收来自其他参与者的数据包
   发送其第一个数据包（数据或控制）。如果新的来源
   跟踪其他参与者（通过SSRC标识符），然后





Schulzrinne等人 标准履历[第59页]
 
RFC 3550                           RTP July 2003


   在发送其第一个数据包之前，新的源可以验证
   其标识符与任何已接收的标识符不冲突，或
   否则再次选择。

8.2碰撞分辨率和环路检测

   虽然SSRC标识符冲突的概率很低，但所有RTP
   实现必须准备好检测碰撞并采取
   适当的行动来解决它们。如果一个来源发现了
   另一个来源正在使用与其相同的SSRC标识符的时间
   自己，它必须发送一个RTCP BYE包为旧的标识符和
   选择另一个随机的。（如下所述，采取这一步
   如果一个接收器发现另外两个接收器，则只有一次
   源是冲突的，它可以保留来自一个的丢包
   来自另一个的数据包当这个可以被不同的检测到时
   源传输地址或CNAME。预计这两个来源
   解决碰撞，使情况不会持续。

   因为随机SSRC标识符对于每个标识符保持全局唯一
   RTP会话，它们也可以用于检测可能的循环
   由混音器或翻译者介绍。循环导致重复
   数据和控制信息，未修改或可能混合
   在以下示例中：

   o翻译器可能不正确地将数据包转发到同一个数据包
      也可以从中收到数据包的组播组
      直接或通过一连串的翻译。在这种情况下，
      同样的数据包出现多次，源于不同
      网络来源。

   o两个翻译器并行设置不正确，即与
      两侧同样的组播组都会转发报文
      从一个组播组到另一个。单向翻译器
      会产生两份; 双向翻译将形成
      循环。

   o混音器可以通过发送到相同的传输来关闭一个循环
      直接或直接接收数据包的目的地
      通过另一个混音器或翻译器。在这种情况下，源可能
      在数据包和中国证监会的混合中都显示为SSRC
      数据包。

   源可能会发现自己的数据包正在被循环，或者那个
   来自另一个源的数据包正在循环（第三方循环）。
   在源的随机选择中的循环和冲突
   标识符导致具有相同SSRC标识符的分组到达
   但是不同的源传输地址，可能是那个
   发起分组的终端系统或中间系统。



Schulzrinne等人 标准轨迹[第60页]
 
RFC 3550                           RTP July 2003


   因此，如果源更改其源传输地址，则可能是
   还要选择一个新的SSRC标识符，以避免被解释为a
   循环源 （这不是必须的，因为在RTP的某些应用中
   来源可能会在会话期间更改地址。）注意
   如果翻译器重新启动并因此更改源代码
   传输地址（例如，更改UDP源端口号）
   它转发数据包，然后所有这些数据包将显示给接收器
   由于原始的SSRC标识符被应用，因此被循环
   来源不会改变。这个问题可以通过保留来避免
   源传输地址在重新启动之间固定，但在任何情况下
   将在接收器超时后解决。

   在翻译的远端发生的循环或碰撞
   如果全部使用源传输地址，则无法检测到混音器
   然而，数据包的副本通过翻译器或混音器，
   当来自两个RTCP SDES的块时，仍然可以检测到冲突
   数据包包含相同的SSRC标识符但不同的CNAME。

   为了检测和解决这些冲突，RTP实现必须
   包括与下面描述的算法相似的算法
   实现可能为哪个数据包选择不同的策略
   相互冲突的第三方来源被保留。描述的算法
   以下忽略与一个新的源或环路冲突的数据包
   建立来源。它解决与参与者的冲突
   通过为旧的标识符发送一个RTCP BYE来拥有自己的SSRC标识符
   选择一个新的。然而，当a引起碰撞时
   循环参与者自己的数据包，算法将选择一个
   新的标识符只有一次，然后忽略来自的数据包
   循环源传输地址。这是避免洪水所必需的
   的BYE数据包。

   该算法需要保留由源索引的表
   标识符并包含源传输地址
   第一RTP分组和接收到该标识符的第一RTCP分组，
   以及该来源的其他状态。两源运输
   需要地址，例如UDP源端口
   RTP和RTCP数据包的数字可能不同。但是，可能是
   假设两个源传输中的网络地址相同
   地址。

   在RTP或RTCP分组中接收的每个SSRC或CSRC标识符
   在源标识符表中查找，以便处理
   数据或控制信息。源的传输地址来自
   数据包与相应的源传输地址进行比较
   该表检测到一个循环或碰撞，如果它们不匹配。对于
   控制数据包，每个元素都有自己的SSRC标识符
   例如SDES块，需要单独查找。（SSRC
   接收报告块中的标识符是异常，因为它



Schulzrinne等人 标准履历[第61页]
 
RFC 3550                           RTP July 2003


   识别记者听到的来源，以及SSRC标识符
   与发送的RTCP数据包的源传输地址无关
   如果没有找到SSRC或者中国证监会，一个新的条目是
   创建。当RTCP BYE数据包是这些表条目时被删除
   收到相应的SSRC标识符并由a验证
   匹配源传输地址，或没有数据包到达后
   相当长的一段时间（见第6.2.1节）。

   请注意，如果同一主机上的两个源正在传输
   在接收机开始操作时，它的源标识符相同
   可能的是收到的第一个RTP包来自其中之一
   第一个RTCP数据包接收到的源来自另一个。
   这将导致错误的RTCP信息与
   RTP数据，但这种情况应该是非常罕见和无害的
   可以忽略它。

   为了跟踪参与者自己的数据包的循环，
   实现也必须单独列出源传输
   已发现有冲突的地址（而不是标识符）。
   在源标识符表中，两个源传输地址
   必须保持单独跟踪冲突的RTP和RTCP数据包。
   请注意，冲突的地址列表通常应该很短
   空。此列表中的每个元素存储源地址加号
   最近收到冲突的数据包的时间。一个
   元素可能在没有冲突的数据包时从列表中删除
   从该来源到达10个RTCP报告的时间
   间隔（见第6.2节）。

   对于所示的算法，假设参与者自己
   源标识符和状态包含在源标识符中
   表。该算法可以进行重组，首先分开
   与参与者自己的源标识符进行比较。

      如果（SSRC或CSRC标识符在源中未找到）
          标识符表）{
          创建存储数据或控制源的新条目
              运输地址，SSRC或中国证监会等国家;
      }

      / *标识符在表* /

      else if（表条目是在接收到控制数据包时创建的
               这是第一个数据包，反之亦然）{
          从该数据包存储源传输地址;
      }
      否则if（来自数据包的源传输地址不匹配
               保存在此标识符的表项中的一个）{




Schulzrinne等人 标准轨迹[第62页]
 
RFC 3550                           RTP July 2003


          / *标识符冲突或循环指示* /

          if（源标识符不是参与者自己的）{
              / *可选错误计数器步骤* /
              if（源标识符来自RTCP SDES块
                  包含与CNAME不同的CNAME项目
                  在表项中）{
                  计算第三方冲突;
              } else {
                  计数第三方循环;
              }
              中止处理数据包或控制元素;
              / *可以选择不同的策略来保持新的来源* /
          }

          / *参与者自己的数据包的冲突或循环* /

          else if（源传输地址在列表中
                   冲突的数据或控制源传输
                   地址）{
              / *可选错误计数器步骤* /
              if（源标识符不是来自RTCP SDES块
                  包含CNAME项或CNAME
                  参与者自己的）{
                  计数自身流量发生循环;
              }
              标记冲突地址列表条目中的当前时间;
              中止处理数据包或控制元素;
          }

          / *新的冲突，更改SSRC标识符* /

          else {
              日志发生碰撞;
              在冲突的数据或控件中创建一个新条目
                  源传输地址列表并标记当前时间;
              发送具有旧SSRC标识符的RTCP BYE分组;
              选择一个新的SSRC标识符;
              在源标识符表中创建一个新条目
                  旧的SSRC加上源运输地址
                  正在处理的数据或控制分组;
          }
      }

   在这种算法中，来自新冲突的源地址的数据包
   将被忽略，原始源地址的数据包将被忽略
   保持。如果没有数据包从原始源到达扩展
   期间，表格条目将被超时，新的来源将被删除



Schulzrinne等人 标准履历[第63页]
 
RFC 3550                           RTP July 2003


   能够接管 如果原始源检测到可能会发生这种情况
   碰撞并移动到新的源标识符，但是在通常情况下
   情况下，将从原始来源接收RTCP BYE数据包
   删除状态，而不必等待超时。

   如果通过混音器接收到原始源地址（即，
   作为中国证监会学习），后来直接收到同一来源，
   可能建议接收器切换到新的源地址
   除非混合中的其他来源将丢失。另外，
   诸如电话的应用，其中一些来源如移动
   实体可以在RTP会话过程中改变地址，
   RTP实现应该修改冲突检测
   算法从新的源传输地址接受数据包。
   为了防止地址之间的翻转，如果一个真正的
   碰撞确实发生，算法应该包括一些手段
   检测这种情况并避免切换。

   当由于碰撞而选择了新的SSRC标识符时，
   候选标识符应首先在源文件中查找
   标识符表，看它是否已被其他一些使用
   资源。如果是这样，必须生成另一个候选人和进程
   重复。

   数据包到组播目的地的循环可能会导致严重的
   网络洪水。所有混音器和翻译器都必须实现一个循环
   检测算法像这里一样，以便它们可以断开循环。
   这应该将超出的流量限制为不超过一个副本
   原始流量的副本，这可能允许会话继续
   从而可以找到并修复循环的原因。但是，
   混音器或翻译器没有正确打破的极端情况
   循环和高流量水平的结果，可能需要结束
   系统完全停止发送数据或控制数据包。这个
   决定可能取决于应用程序。错误条件应该是
   酌情指出。传输可能再次尝试
   经过长时间的随机时间（分钟数）。

8.3使用分层编码

   对于在单独RTP会话上传输的分层编码（见
   第2.4节），应该使用单个SSRC标识符空间
   应该使用所有层和核心（基础）层的会话
   用于SSRC标识符分配和冲突解决。当一个
   源码发现它已经发生冲突，它传输一个RTCP BYE
   仅在基本层上分组，但将SSRC标识符更改为
   所有层的新价值。






Schulzrinne等人 标准轨迹[第64页]
 
RFC 3550                           RTP July 2003


9。安全

   较低层协议可能最终提供所有的安全性
   可能需要RTP应用的服务，包括
   认证，诚信和保密。这些服务有
   在[ 27 ]中。自初始音视频
   使用RTP的应用程序在此之前需要保密服务
   服务可用于IP层，保密服务
   在下一节中描述的定义用于RTP和RTCP。
   这里列出了这一描述，以编纂现有做法。新
   RTP的应用可以实现这种RTP特定的机密性
   服务向后兼容，和/或他们可以实现
   替代安全服务。RTP协议的开销
   这种保密服务很低，所以罚款将会很小
   如果这项服务在将来被其他服务所淘汰。

   或者，其他服务，服务的其他实现和
   未来可能为RTP定义其他算法。在
   特别地，称为安全实时传输协议的RTP简档
   （SRTP）[ 28 ]正在开发以提供RTP的机密性
   有效载荷，同时将RTP头部清除，使链路级别
   报头压缩算法仍然可以运行。预计的
   SRTP将成为许多应用程序的正确选择。基于SRTP
   在高级加密标准（AES）上提供更强大的功能
   安全性比这里描述的服务。没有声称是
   这里提供的方法适用于特定的安全性
   需要。配置文件可以指定哪些服务和算法应该是
   由申请提供，并可提供指导
   适当使用。

   密钥分发和证书不在此范围内
   文件。

9.1保密

   保密意味着只有预期的接收者可以解码
   收到的包; 对于其他人来说，数据包不含有用
   信息。内容的保密性是通过实现的
   加密。

   当需要根据该方法加密RTP或RTCP时
   在本节中指定的，将封装的所有八位字节
   用于在单个下层分组中的传输被加密为a
   单元。对于RTCP，每个单元重新绘制的32位随机数必须是
   在加密之前加入该单元。对于RTP，没有前缀
   前置; 而是，序列号和时间戳字段是
   用随机偏移初始化。这被认为是弱者




Schulzrinne等人 标准履历[第65页]
 
RFC 3550                           RTP July 2003


   初始化矢量（IV）因为随机性差。在
   另外，如果随后的字段，SSRC可以被操纵
   敌人，还有进一步弱点的加密方法。

   对于RTCP，实现可以隔离各个RTCP分组
   在复合RTCP包中分成两个单独的复合RTCP包，
   一个被加密，一个被清除。例如，
   SDES信息可能会在接收报告发送时被加密
   在明确容纳不是私有的第三方监视器
   加密密钥。在这个例子中，4，SDES
   信息必须附加到没有报告的RR数据包（和
   随机数）以满足所有复合RTCP的要求
   数据包以SR或RR数据包开头。SDES CNAME项目是
   在加密或未加密的数据包中都需要，但不能同时使用。
   相同的SDES信息不能在两个数据包中携带
   这可能会危及加密。

             UDP包UDP包
   ----------------------------- --------------------- ---------
   [random] [RR] [SDES #CNAME ...] [SR #senderinfo＃site1＃site2]
   ----------------------------- --------------------- ---------
             加密未加密

   ＃：SSRC标识符

       图4：加密和未加密的RTCP数据包

   加密的存在和使用正确的密钥是
   由接收者通过报头或有效载荷有效性检查确认。
   给出了RTP和RTCP报头的这种有效性检查的示例
   附录A.1和A.2。

   与初始化的现有实现一致RFC 1889 
   中RTP的规范，默认的加密算法是
   密码块链接中的数据加密标准（DES）算法
   （CBC）模式，如RFC 1423 [ 29 ] 第1.1节所述，除了
   如P所述，填充到8个八位字节的倍数
   在第5.1节。由于随机，初始化向量为零
   值在RTP头或随机前缀中提供
   复合RTCP数据包。有关使用CBC初始化的详细信息
   载体，参见[ 30 ]。

   支持此处指定的加密方法的实现
   应该始终以CBC模式支持DES算法作为默认值
   这种方法的密码最大化互操作性。这个方法是
   因为它被证明是容易和实用的
   用于实验音视频工具的操作
   互联网。然而，DES已经被发现太容易破碎了。



Schulzrinne等人 标准轨迹[第66页]
 
RFC 3550                           RTP July 2003


   推荐使用更强大的加密算法，例如
   使用三重DES代替默认算法。此外，
   安全CBC模式要求每个数据包的第一个数据块被异或
   具有与密码块相同大小的随机独立IV
   尺寸。对于RTCP，这是（部分地）通过预先设置的每个实现的
   具有32位随机数的数据包，每个独立地选择
   包。对于RTP，时间戳和序列号从随机开始
   值，但连续的数据包不会被独立随机化。
   应该注意的是，两种情况下的随机性（RTP和RTCP）
   有限 高安全性应用应该考虑其他，更多
   常规的保护手段。其他加密算法也许是
   通过非RTP方式为会话动态指定。尤其是，基于AES 
   的SRTP配置文件[ 28 ]正在开发中
   帐号已知明文和CBC明文操作的关注，以及
   将来是正确的选择。

   作为在IP级别或RTP级别的加密的替代方案
   如上所述，配置文件可以为其定义附加的有效载荷类型
   加密编码。那些编码必须指定如何填充和
   处理加密的其他方面。这个方法
   只允许加密数据，同时留下标题
   清除所需的应用程序。这可能是特别的
   对处理解密的硬件设备有用
   解码。它对链接级别的应用程序也是有价值的
   期望RTP和下层报头的压缩
   有效载荷（但不是地址）的机密性就足够了
   因为标题的加密妨碍了压缩。

9.2认证和消息完整性

   验证和消息完整性服务没有定义
   RTP级别，因为没有这些服务将不会直接可行
   一个关键的管理基础设施。预计认证
   而完整性服务将由下层协议提供。

10。拥塞控制

   互联网上使用的所有传输协议需要解决
   拥塞控制在某种程度上[ 31 ]。RTP不是例外，但是
   因为通过RTP传输的数据通常是非弹性的（生成的）
   以固定或受控的速率），控制拥堵的手段
   RTP可能与其他传输协议的RTP有很大不同
   如TCP。在某种意义上，非弹性降低了风险
   拥塞，因为RTP流不会扩展消耗所有
   可用带宽作为TCP流可以。然而，也是非弹性的
   意味着RTP流不能随意地减少它的负载
   网络，以消除发生拥塞时。




Schulzrinne等人 标准履历[第67页]
 
RFC 3550                           RTP July 2003


   由于RTP可以用于许多应用中
   不同的上下文，没有一个拥塞控制机制
   这将为所有人工作。因此，拥塞控制应该是
   在每个RTP配置文件中定义适当。对于某些配置文件，它
   可能足以包括适用性声明限制
   将该配置文件用于避免拥塞的环境
   通过工程。对于其他配置文件，具体方法如数据
   可能需要基于RTCP反馈的速率适配。

11。通过网络和传输协议实现RTP

   本节介绍携带RTP数据包的具体问题
   特定的网络和传输协议。以下规则
   除非在此之外被协议特定的定义所取代，否则适用
   规范。

   RTP依赖于底层协议来提供多路分解
   RTP数据和RTCP控制流。对于UDP和类似协议，
   RTP应该使用偶数目的端口号和相应的
   RTCP流应该使用下一个较高（奇数）目标端口号。
   对于采用单个端口号作为参数的应用程序
   从该数字导出RTP和RTCP端口对，如果是奇数
   然后应用程序应该用该代码替换该数字
   下一个较低（偶数）数字用作端口对的基数。对于
   RTP和RTCP目标端口号的应用程序
   通过显式的，单独的参数指定（使用信令
   协议或其他方式），应用程序可以忽略
   端口号偶数/奇数连续的限制
   尽管仍然鼓励使用偶数/奇数端口对。该
   RTP和RTCP端口号必须不一样，因为RTP依赖于
   端口号解复用RTP数据和RTCP控制
   流。

   在单播会话中，两个参与者需要识别端口对
   用于接收RTP和RTCP数据包。两个参与者可以使用
   相同的端口对。参与者不得假定源端口
   可以使用传入的RTP或RTCP数据包作为目标
   端口用于传出RTP或RTCP数据包。当RTP数据包是
   两个方向发送，每个参与者的RTCP SR数据包
   必须发送到另一个参与者指定的端口
   接收RTCP。RTCP SR报文组合发送方信息
   为外发数据加接收报告信息
   传入数据。如果一方没有主动发送数据（见第
   6.4 节），则会发送RTCP RR数据包。

   推荐分层编码应用（见第
   2.4 节）使用一组连续的端口号。端口号必须是
   由于现有操作普遍存在缺陷



Schulzrinne等人 标准轨迹[第68页]
 
RFC 3550                           RTP July 2003


   防止使用多个多播的同一端口的系统
   地址，对于单播，只有一个允许的地址。
   因此，对于层n，数据端口为P + 2n，控制端口为P
   + 2n + 1。当使用IP多播时，地址必须也是
   因为组播路由和组成员资格被管理
   地址粒度。但是，分配连续的IP
   无法假定多播地址，因为某些组可能需要
   不同的范围，因此可以从不同的范围分配
   地址范围。

   前一段与SDP规范RFC 2327 
   [ 15 ] 相冲突，表示对于这两个地址都是非法的
   要在同一会话描述中指定多个端口
   因为地址与端口的关联可能是模糊的。
   这个限制将在修订中放宽
   RFC 2327允许相同数量的地址和端口
   用一对一映射指定。

   RTP数据包不包含长度字段或其他描述，
   因此，RTP依赖于基础协议来提供
   长度指示。RTP包的最大长度仅限于此
   通过底层协议。

   如果RTP数据包将在底层协议中携带
   提供连续八位字节流的抽象，而不是
   消息（packet），RTP包的封装必须是
   定义为提供框架机制。如果还需要框架
   底层协议可能包含填充，使得的范围
   无法确定RTP有效载荷。框架机制不是
   这里定义。

   配置文件可以指定即使在RTP时使用的成帧方法
   在提供框架以允许的协议中携带
   在一个下层协议数据单元中携带多个RTP分组，
   例如UDP数据包。在一个网络中携带多个RTP数据包
   传输分组减少了报头开销并且可以简化
   不同流之间的同步。

12。协议常数摘要

   本节包含定义的常量的汇总列表
   本规范。

   RTP有效载荷类型（PT）常数在配置文件中定义
   比这个文件。然而，RTP头的八位字节
   包含标记位和有效载荷类型必须避免保留
   值为200和201（十进制），以区分RTP分组与RTCP
   SR和RR报文类型，用于描述报头验证过程



Schulzrinne等人 标准轨迹[第69页]
 
RFC 3550                           RTP July 2003


   在附录A.1中。对于一个标记位的标准定义和a
   7位有效载荷类型字段如本规范所示，这一点
   限制意味着保留有效载荷类型72和73。

12.1 RTCP包类型

   缩写。名称值
   SR发送者报告200
   RR接收机报告201
   SDES源描述202
   拜拜再见203
   APP应用定义204

   这些类型值选择在200-204范围内进行改进
   与RTP数据包相比RTCP数据包的头部有效性检查
   其他不相关的数据包。当RTCP数据包类型字段进行比较时
   到RTP报头的相应八位字节，该范围对应
   标记位为1（通常不在数据包中）
   并且标准有效载荷类型字段的高位为1（因为
   静态有效载荷类型通常在低一半中定义）。
   该范围也被选择为与数字0的距离
   255，因为全零和全是常用的数据模式。

   由于所有复合RTCP包必须以SR或RR开头，这些代码
   被选为偶数/奇偶对以允许RTCP有效性检查
   用掩码和值测试最大位数。

   可以通过IANA注册其他RTCP数据包类型（参见
   第15节）。

12.2 SDES类型

   缩写。名称值
   SDES列表0的末尾
   CNAME规范名称1
   NAME用户名2
   EMAIL用户的电子邮件地址3
   PHONE用户手机号码4
   LOC地理位置5
   工具应用程序名称或工具6
   注意源7的注意事项
   PRIV私人扩展8

   可以通过IANA注册其他SDES类型（参见第
   15 节）。






Schulzrinne等人 标准轨迹[第70页]
 
RFC 3550                           RTP July 2003


13。RTP配置文件和有效载荷格式规范

   特定应用程序的RTP的完整规范将会
   需要一个或多个这样描述的两种类型的伴随文档：
   配置文件和有效载荷格式规范。

   RTP可以用于具有稍微不同的各种应用
   要求。适应这些要求的灵活性是
   通过在主协议中允许多个选择来提供
   规范，然后选择适当的选择或定义
   特定环境和应用程序类的扩展
   单独的个人资料文件。通常应用程序将会运行
   在特定RTP会话中只有一个配置文件，所以没有
   在RTP协议本身内的显式指示是哪一个
   个人资料正在使用中 音频和视频应用的配置文件可能是
   发现在RFC 3551的伴侣中。配置文件通常标题为“RTP”
   个人资料...“。

   第二种类型的伴随文件是有效载荷格式
   规范，它定义了一种特定类型的有效载荷数据，
   如H.261编码视频，应在RTP中携带。这些
   文档通常标题为“XYZ的RTP有效载荷格式”
   音频/视频编码“。有效载荷格式可能在多种情况下有用
   并且因此可以独立于任何特定的方式来定义
   个人资料。配置文件然后负责分配
   如果需要，该格式默认映射到有效负载类型值。

   在本说明书中，已经确定了以下项目
   为了在配置文件中可能的定义，但是这个列表不是意思
   详尽无遗：

   RTP数据头：RTP数据头中包含的八位字节
      标记位和有效载荷类型字段可以由a重新定义
      配置符合不同要求，例如更多或更多
      较少的标记位（第5.3节，第18页）。

   有效载荷类型：假设包含有效载荷类型字段，
      配置文件通常定义一组有效载荷格式（例如，
      媒体编码）和这些格式的默认静态映射
      有效载荷类型值。可以定义一些有效载荷格式
      通过参考单独的有效载荷格式规范。对于每一个
      定义的负载类型，配置文件必须指定RTP时间戳
      要使用的时钟速率（第5.1节，第14页）。

   RTP数据头添加：可以附加附加字段
      固定的RTP数据头，如果有一些额外的功能
      需要独立于配置文件的各种应用程序
      有效载荷类型（第5.3节，第18页）。



Schulzrinne等人 标准轨迹[第71页]
 
RFC 3550                           RTP July 2003


   RTP数据头扩展：前16位的内容
      RTP数据头扩展结构必须定义如果使用
      该机制是允许在配置文件下
      实现特定扩展（第5.3.1节，第18页）。

   RTCP数据包类型：新的应用类特定的RTCP数据包
      类型可以被定义并注册到IANA。

   RTCP报告间隔：配置文件应该指定值
      在6.2节中提出了常用的常数
      将使用RTCP报告间隔的计算。那些是
      会话带宽的RTCP分数，最小报告
      间隔和发送方和接收方之间的带宽分配。
      配置文件可以指定备用值（如果已经存在）
      证明以可扩展的方式工作。

   SR / RR扩展：可以定义扩展部分
      如果有其他信息，则RTCP SR和RR数据包
      应定期报告发送者或接收者
      （第6.4.3节，第42和43页）。

   SDES使用：配置文件可以指定相对优先级
      要完全传输或排除的RTCP SDES项目（第
      6.3.9 节）; CNAME项目的替代语法或语义
      （第6.5.1节）; LOC项目的格式（第6.5.5节）; 该
      NOTE项目的语义和使用（第6.5.7节）; 或新的SDES
      要在IANA注册的项目类型。

   安全性：配置文件可以指定哪些安全服务和
      算法应由应用程序提供，并可提供
      指导他们的适当使用（第9节，第65页）。

   字符串到键映射：配置文件可以指定用户提供的方式
      密码或密码被映射成加密密钥。

   拥塞：配置文件应该指定拥塞控制
      适合该配置文件的行为。

   基础协议：使用特定的底层网络或
      可能需要携带RTP数据包的传输层协议。

   传输映射：RTP和RTCP映射到传输层
      地址，例如UDP端口，而不是标准映射第11节 
      定义。可以指定68。







Schulzrinne等人 标准轨迹[第72页]
 
RFC 3550                           RTP July 2003


   封装：可以定义RTP包的封装
      允许多个RTP数据包在一个下层承载
      分组或提供框架的底层协议不
      已经这样做了（第11节，第69页）。

   预计每个人都不需要新的配置文件
   应用。在一个应用程序类中，最好是
   扩展现有的配置文件，而不是创建一个新的配置文件
   促进各个应用程序之间的互操作
   通常只能运行一个配置文件。简单的扩展，如
   额外的有效载荷类型值或RTCP分组类型的定义可以
   通过IANA注册并发布他们来完成
   在配置文件或有效载荷格式的增编中的描述
   规范。

14。安全注意事项

   RTP与基础相同的担保责任
   协议。例如，冒名顶替者可以伪造来源或目的地
   网络地址，或更改标题或有效载荷。在RTCP中
   CNAME和NAME信息可能用于模拟另一个
   参与者。另外，RTP可以通过IP多播发送，
   没有提供发送方知道所有接收者的直接方法
   数据发送，因此不会影响隐私。没错，
   用户可能对音频和视频的隐私问题更敏感
   沟通比传统形式更为传统
   网络通信[ 33 ]。所以使用安全
   RTP机制很重要。这些机制在
   第9节。

   RTP级转换器或混频器可用于允许RTP流量
   到达防火墙后面的主机。适当的防火墙安全
   原则和做法，超出了这个范围
   文件，应在设计和安装中遵循这些
   设备和入门RTP应用在后面使用
   防火墙。

15。IANA注意事项

   可以注册附加的RTCP分组类型和SDES项目类型
   通过互联网号码分配机构（IANA）。因为这些
   数字空间很小，允许无限制地注册新的
   价值观不会审慎。方便审查请求和
   在多个应用程序，请求之间促进新类型的共享使用
   用于注册新值必须记录在RFC或其他文件中
   永久和随时可用的参考，如产品
   另一个合作标准机构（例如，ITU-T）。其他请求可能
   在“指定专家”的指导下也被接受。



Schulzrinne等人 标准轨迹[第73页]
 
RFC 3550                           RTP July 2003


   （联系IANA获取当前专家的联系信息。）

   RTP配置文件规范应该向IANA注册
   形式为“RTP / xxx”，其中xxx是缩写
   个人资料标题。这些名称由更高级别的控制使用
   协议，例如会话描述协议（SDP），RFC 2327 
   [ 15 ]，以引用传输方法。

16。知识产权声明

   IETF对任何的有效性或范围不承担任何责任
   知识产权或其他可能声称的权利
   涉及实施或使用的技术
   本文件或此类权利下的任何许可证的程度
   可能或可能不可用; 它也不代表它
   已经努力确定任何此类权利。关于信息
   IETF关于标准轨迹权利的程序
   标准相关文档可以在BCP-11中找到。的副本
   索赔的权利可供出版和任何保证
   许可证可以提供，或尝试的结果
   获得一般许可或使用许可
   本规范的实施者或用户的专有权利可以
   可从IETF秘书处获得。

   IETF邀请任何有兴趣的方面引起注意
   版权，专利或专利申请或其他专利
   这些权利可能涵盖可能需要执行的技术
   这个标准。请向IETF执行官处理信息
   导向器。

17。致谢

   本备忘录是基于IETF音频/视频内的讨论
   运输工作组由Stephen Casner和Colin Perkins主持。
   目前的协议起源于网络语音协议
   和分组视频协议（Danny Cohen和Randy Cole）和
   大容量应用程序实现的协议（Van Jacobson和Steve
   McCanne）。Christian Huitema提供了随机标识符的想法
   发电机。定时器的广泛分析和仿真
   重新考虑算法由Jonathan Rosenberg完成。该
   分层编码的添加由Michael Speer和
   史蒂夫·麦考恩









Schulzrinne等人 标准履历[第74页]
 
RFC 3550                           RTP July 2003


附录A  - 算法

   我们提供RTP发送方和接收方方面的C代码示例
   算法。可能还有其他的实现方法
   在特定的操作环境中更快或具有其他优点。
   这些实施说明仅供参考
   旨在澄清RTP规范。

   以下定义用于所有示例; 为了清楚和
   简洁，结构定义仅适用于32位大型
   endian（最重要的八位位组第一）架构。位字段是
   假定以大排序的顺序紧紧包装，没有
   额外的填充。需要修改一个
   便携式实施。

   / *
    * rtp.h  -  RTP头文件
    * /
   #include <sys / types.h>

   / *
    *以下类型定义适用于32位体系结构
    *可能需要针对16位或64位架构进行调整。
    * /
   typedef unsigned char u_int8;
   typedef unsigned short u_int16;
   typedef unsigned int u_int32;
   typedef short int16;

   / *
    *当前协议版本。
    * /
   #define RTP_VERSION 2

   #define RTP_SEQ_MOD（1 << 16）
   #define RTP_MAX_SDES 255 / * SDES的最大文本长度* /

   typedef枚举{
       RTCP_SR = 200，
       RTCP_RR = 201，
       RTCP_SDES = 202，
       RTCP_BYE = 203，
       RTCP_APP = 204
   } rtcp_type_t;

   typedef枚举{
       RTCP_SDES_END = 0，
       RTCP_SDES_CNAME = 1，



Schulzrinne等人 标准轨迹[第75页]
 
RFC 3550                           RTP July 2003


       RTCP_SDES_NAME = 2，
       RTCP_SDES_EMAIL = 3，
       RTCP_SDES_PHONE = 4，
       RTCP_SDES_LOC = 5，
       RTCP_SDES_TOOL = 6，
       RTCP_SDES_NOTE = 7，
       RTCP_SDES_PRIV = 8
   } rtcp_sdes_type_t;

   / *
    * RTP数据头
    * /
   typedef struct {
       unsigned int version：2; / *协议版本* /
       unsigned int p：1; / * padding flag * /
       unsigned int x：1; / *标题扩展名*
       unsigned int cc：4; / *中国证监会计数* /
       unsigned int m：1; / *标记位* /
       unsigned int pt：7; / *负载类型* /
       unsigned int seq：16; /* 序列号 */
       u_int32 ts; / *时间戳* /
       u_int32 ssrc / *同步源* /
       u_int32 csrc [1] / *可选证监会名单* /
   } rtp_hdr_t;

   / *
    * RTCP公共标题字
    * /
   typedef struct {
       unsigned int version：2; / *协议版本* /
       unsigned int p：1; / * padding flag * /
       unsigned int count：5; / *由数据包类型* /
       unsigned int pt：8; / * RTCP包类型* /
       u_int16长度 / * pkt len用字，w / o这个词* /
   } rtcp_common_t;

   / *
    *版本，填充位和数据包类型对的Big-endian掩码
    * /
   #define RTCP_VALID_MASK（0xc000 | 0x2000 | 0xfe）
   #define RTCP_VALID_VALUE（（RTP_VERSION << 14）| RTCP_SR）

   / *
    *接待报告块
    * /
   typedef struct {
       u_int32 ssrc / *数据源被报告* /
       无符号int分数：8; / *自上次SR / RR * /



Schulzrinne等人 标准轨迹[第76页]
 
RFC 3550                           RTP July 2003


       int丢了：24; / *累积。没有。pkts丢了（签名！）* /
       u_int32 last_seq; / *延长最后一页。没有。收到* /
       u_int32抖动 / * interarrival jitter * /
       u_int32 lsr; / *来自此源的最后一个SR数据包* /
       u_int32 dlsr / *自上次SR数据包以来的延迟* /
   } rtcp_rr_t;

   / *
    * SDES项目
    * /
   typedef struct {
       u_int8类型 / *项目类型（rtcp_sdes_type_t）* /
       u_int8长度 / *项目长度（以八位字节为单位）* /
       char数据[1]; / * text，not null-terminated * /
   } rtcp_sdes_item_t;

   / *
    *一个RTCP数据包
    * /
   typedef struct {
       常见的rtcp_common_t / * common header * /
       工会{
           / *发件人报告（SR）* /
           struct {
               u_int32 ssrc / *发送者报告* /
               u_int32 ntp_sec; / * NTP时间戳* /
               u_int32 ntp_frac;
               u_int32 rtp_ts; / * RTP时间戳* /
               u_int32 psent; / *数据包发送* /
               u_int32 osent / *八位字节发送* /
               rtcp_rr_t rr [1]; / *可变长度列表* /
           } sr;

           / *接待报告（RR）* /
           struct {
               u_int32 ssrc / *接收者生成此报告* /
               rtcp_rr_t rr [1]; / *可变长度列表* /
           } rr;

           / *源描述（SDES）* /
           struct rtcp_sdes {
               u_int32 src; / *第一次SSRC /中国证监会* /
               rtcp_sdes_item_t item [1]; / * SDES项目清单* /
           } sdes;

           / * BYE * /
           struct {
               u_int32 src [1]; / *来源清单* /



Schulzrinne等人 标准履历[第77页]
 
RFC 3550                           RTP July 2003


               / *无法表示尾随文本的原因* /
           再见
       } r
   } rtcp_t;

   typedef struct rtcp_sdes rtcp_sdes_t;

   / *
    *每个源的状态信息
    * /
   typedef struct {
       u_int16 max_seq; / *最高seq。数字* /
       u_int32周期; / *转移次数。数字周期* /
       u_int32 base_seq; / * base seq number * /
       u_int32 bad_seq; / * last'bad'seq number + 1 * /
       u_int32缓刑 / * sequ。数据包直到源有效* /
       收到的u_int32 / *收到数据包* /
       u_int32 expected_prior; / *预计在最后时间间隔* /
       u_int32 received_prior; / *最后间隔收到的数据包* /
       u_int32过境 / *相对时间为prev pkt * /
       u_int32抖动 / *估计抖动* /
       / * ... * /
   } 资源;

A.1 RTP数据报头有效性检查

   RTP接收者应检查RTP报头的有效性
   传入的数据包，因为它们可能被加密或可能来自a
   不同的应用程序恰巧被误解。同样，如果
   根据第9节描述的方法启用加密，
   需要头部有效性检查来验证传入的数据包
   已经正确解密，尽管头文件失败
   有效性检查（例如，未知的有效载荷类型）可能不一定
   表示解密失败。

   对于来自a的RTP数据包，只能进行弱的有效性检查
   以前没有听说过的来源：

   o RTP版本字段必须等于2。

   o有效载荷类型必须是已知的，特别是它不能
      等于SR或RR。

   o如果P位被设置，则数据包的最后一个八位字节必须
      包含有效的八位字节数，特别是小于总数
      数据包长度减去报头大小。





Schulzrinne等人 标准轨迹[第78页]
 
RFC 3550                           RTP July 2003


   o如果配置文件未指定，则X位必须为零
      可以使用标题扩展机制。否则，扩展
      长度字段必须小于总包大小减去
      固定头长度和填充。

   o包的长度必须与CC和有效载荷一致
      类型（如果有效载荷具有已知长度）。

   最后三次检查有点复杂，并不总是可能的，
   只剩下前两个总共只有几个位。如果SSRC
   分组中的标识符是之前已经接收到的
   该数据包可能是有效的，并检查序列号是否为
   在预期范围内进一步验证。如果SSRC
   标识符之前还没有被看到，那么数据包就是携带的
   标识符可能被认为是无效的，直到它们的数量很少
   以连续的序列号到达。那些无效数据包可能
   被丢弃，或者一旦验证就可以存储和传送
   如果造成的延误是可以接受的，已经实现了。

   下面显示的例程update_seq确保声明了源
   在收到MIN_SEQUENTIAL包后才有效
   序列。它还验证新的序列号seq
   接收到数据包并更新数据包的序列状态
   来源于结构中的点数。

   当第一次听到新的来源，就是其SSRC
   标识符不在表中（参见第8.2节）和每个源
   状态被分配给它，s->试用设置为数量
   在声明源有效之前所需的顺序数据包
   （参数MIN_SEQUENTIAL）和其他变量初始化：

      init_seq（s，seq）;
      s-> max_seq = seq  -  1;
      s->试用期= MIN_SEQUENTIAL;

   非零s->试用标记来源尚未有效
   状态可以在短时间超时而不是长时间之后丢弃，
   如第6.2.1节所述。

   在将源视为有效之后，考虑序列号
   如果在s-> max_seq之前不超过MAX_DROPOUT，则不会有效
   比MAX_MISORDER落后。如果新序列号超前
   max_seq模数RTP序列号范围（16位），但是
   小于max_seq，它已经包围和（移位）计数
   的序列号周期增加。返回值1
   以指示有效的序列号。





Schulzrinne等人 标准轨迹[第79页]
 
RFC 3550                           RTP July 2003


   否则返回值为零，表示验证
   失败，并且存储坏序列号加1。如果下一个
   接收到的数据包携带下一个更高的序列号，它是
   认为可能引起的新分组序列的有效启动
   通过延长退出或源重新启动。由于多次完成
   序列号周期可能已经丢失，丢包
   统计信息重置。

   基于最大值显示参数的典型值
   在50个分组/秒的时间为2秒，最大为2
   辍学1分钟。退出参数MAX_DROPOUT应为a
   小部分的16位序列号空间给出
   重新启动后新序列号的合理概率
   不能落在序列号之前的可接受范围内
   重新开始。

   void init_seq（source * s，u_int16 seq）
   {
       s-> base_seq = seq;
       s-> max_seq = seq;
       s-> bad_seq = RTP_SEQ_MOD + 1; / * so seq == bad_seq is false * /
       s-> cycles = 0;
       s-> received = 0;
       s-> received_prior = 0;
       s-> expected_prior = 0;
       / *其他初始化* /
   }

   int update_seq（source * s，u_int16 seq）
   {
       u_int16 udelta = seq  -  s-> max_seq;
       常量int MAX_DROPOUT = 3000;
       const int MAX_MISORDER = 100;
       const int MIN_SEQUENTIAL = 2;

       / *
        *源无效，直到MIN_SEQUENTIAL数据包为止
        *已收到顺序序列号。
        * /
       如果（s->试用）{
           / *数据包是顺序的* /
           if（seq == s-> max_seq + 1）{
               S-> probation--;
               s-> max_seq = seq;
               if（s-> probation == 0）{
                   init_seq（s，seq）;
                   S->接收++;
                   返回1;



Schulzrinne等人 标准轨迹[第80页]
 
RFC 3550                           RTP July 2003


               }
           } else {
               s->试用期= MIN_SEQUENTIAL  -  1;
               s-> max_seq = seq;
           }
           返回0;
       } else if（udelta <MAX_DROPOUT）{
           / *按照允许的差距* /
           if（seq <s-> max_seq）{
               / *
                *序列号包装 - 计数另外64K周期。
                * /
               s-> cycles + = RTP_SEQ_MOD;
           }
           s-> max_seq = seq;
       } else if（udelta <= RTP_SEQ_MOD  -  MAX_MISORDER）{
           / *序列号做了很大的跳跃* /
           if（seq == s-> bad_seq）{
               / *
                *两个连续的数据包 - 假设对方
                *重新启动，而不告诉我们只是重新同步
                *（即假装这是第一个包）。
                * /
               init_seq（s，seq）;
           }
           else {
               s-> bad_seq =（seq + 1）＆（RTP_SEQ_MOD-1）;
               返回0;
           }
       } else {
           / *复制或重新排序的数据包* /
       }
       S->接收++;
       返回1;
   }

   可以使有效性检查更强，需要两个以上
   数据包顺序。缺点是更多的
   初始数据包将被丢弃（或在队列中延迟）
   高丢包率可能会阻止验证。但是，因为
   如果RTCP分组是RTCP报头验证相对较强
   在数据包之前从一个源接收，计数可以
   调整为仅需要两个数据包。如果
   应用程序可以容忍几秒钟的初始数据丢失
   可以选择从源中丢弃所有数据包，直到有效
   从该源接收到RTCP数据包。





Schulzrinne等人 标准履历[第81页]
 
RFC 3550                           RTP July 2003


   根据应用和编码，算法可能会被利用
   有关进一步验证的有效载荷格式的额外知识。
   对于所有的时间戳增量相同的有效载荷类型
   数据包，时间戳值可以从以前的预测
   使用序列号从同一个源接收到的数据包
   差异（假设有效载荷类型没有变化）。

   强大的“快速通道”检查是可能的，因为它的概率很高
   新接收的RTP数据的报头中的前四个八位位组
   数据包将与之前的数据包相同
   相同的SSRC，除了序列号将增加1。
   类似地，单条目缓存可用于更快的SSRC查找
   在通常从一个来源接收数据的应用中
   时间。

A.2 RTCP标题有效性检查

   以下检查应适用于RTCP数据包。

   o RTP版本字段必须等于2。

   o复合中第一个RTCP数据包的有效载荷类型字段
      数据包必须等于SR或RR。

   o对于a的第一个数据包，填充位（P）应为零
      复合RTCP包，因为填充应该只应用，如果它
      是最后一个数据包。

   o单个RTCP数据包的长度字段必须相加
      接收到的复合RTCP包的总长度。这个
      是一个相当强大的支票。

   下面的代码片段执行所有这些检查。包
   由于未知的数据包类型，不会检查后续数据包的类型
   可能存在，应该被忽略。

      u_int32 len / *复合RTCP数据包的长度字*
      rtcp_t * r; / * RTCP header * /
      rtcp_t * end; / *复合RTCP包结束* /

      if（（*（u_int16 *）r＆RTCP_VALID_MASK）！= RTCP_VALID_VALUE）{
          / *包格式错误* /
      }
      end =（rtcp_t *）（（u_int32 *）r + len）;

      do r =（rtcp_t *）（（u_int32 *）r + r-> common.length + 1）;
      while（r <end && r-> common.version == 2）;




Schulzrinne等人 标准轨迹[第82页]
 
RFC 3550                           RTP July 2003


      if（r！= end）{
          / *包格式错误* /
      }

A.3确定预期和丢失的数据包数量

   为了计算丢包率，RTP包的数量
   预期和实际收到每个来源需要知道，
   使用在struct source中定义的每个源的状态信息
   在下面的代码中通过指针引用。数据包数量
   收到的只是数据包到达时的计数，包括任何数据包
   迟到或重复的数据包。预期的包数可以是
   由接收机计算为最高之间的差异
   接收的序列号（s-> max_seq）和第一序列号
   已收到（s-> base_seq）。因为序列号只有16位
   并将包裹，有必要扩展最高的顺序
   具有序列号环绕的（移位）计数的数字
   （S->个循环）。接收到的数据包数和周期数
   在附录A.1中维护RTP头部有效性检查例程。

      extended_max = s-> cycles + s-> max_seq;
      expected = extended_max  -  s-> base_seq + 1;

   丢包的数量被定义为数据包的数量
   预期减少实际接收的数据包数量：

      失去=预期 -  s->收到;

   由于这个有符号的数字是以24位的方式进行的，因此应该被钳位
   在0x7fffff为正的损失或0x800000为负的损失，而不是
   比环绕。

   在上一个报告间隔期间丢包的分数
   （由于发送了先前的SR或RR数据包）由...计算
   预期和接收的数据包数量差异
   interval，其中expected_prior和received_prior是值
   当前一个接收报告生成时保存：

      expected_interval = expected  -  s-> expected_prior;
      s-> expected_prior = expected;
      received_interval = s-> received  -  s-> received_prior;
      s-> received_prior = s-> received;
      lost_interval = expected_interval  -  received_interval;
      if（expected_interval == 0 || lost_interval <= 0）fraction = 0;
      else fraction =（lost_interval << 8）/ expected_interval;

   所得分数是具有二进制数的8位固定点数
   指向左边缘。



Schulzrinne等人 标准轨迹[第83页]
 
RFC 3550                           RTP July 2003


A.4生成RTCP SDES数据包

   此函数将一个SDES块构建到由argc组成的缓冲区b中
   以数组类型，值和长度提供的项目。它返回一个
   指向b中下一个可用位置的指针。

   char * rtp_write_sdes（char * b，u_int32 src，int argc，
                        rtcp_sdes_type_t type []，char * value []，
                        int length []）
   {
       rtcp_sdes_t * s =（rtcp_sdes_t *）b;
       rtcp_sdes_item_t * rsp
       int i
       int len
       内衬

       / * SSRC标题* /
       s-> src = src;
       rsp =＆s-> item [0];

       / * SDES项目* /
       for（i = 0; i <argc; i ++）{
           rsp-> type = type [i];
           len = length [i];
           if（len> RTP_MAX_SDES）{
               / *无效长度，可能要采取其他动作* /
               len = RTP_MAX_SDES;
           }
           rsp-> length = len;
           memcpy（rsp-> data，value [i]，len）;
           rsp =（rtcp_sdes_item_t *）＆rsp-> data [len];
       }

       / *以终结标记终止，并将其填充到下一个4字节边界* /
       len =（（char *）rsp） -  b;
       pad = 4  - （len＆0x3）;
       b =（char *）rsp;
       while（pad--）* b ++ = RTCP_SDES_END;

       返回b
   }










Schulzrinne等人 标准履历[第84页]
 
RFC 3550                           RTP July 2003


A.5解析RTCP SDES数据包

   此功能解析SDES数据包，调用函数find_member（）
   找到指向给定的会话成员的信息的指针
   SSRC标识符和member_sdes（）来存储新的SDES信息
   为该会员 此函数需要一个指向标题的指针
   RTCP数据包。

   void rtp_read_sdes（rtcp_t * r）
   {
       int count = r-> common.count;
       rtcp_sdes_t * sd =＆r-> r.sdes;
       rtcp_sdes_item_t * rsp，* rspn;
       rtcp_sdes_item_t * end =（rtcp_sdes_item_t *）
                               （（u_int32 *）r + r-> common.length + 1）;
       来源*

       而（--count> = 0）{
           rsp =＆sd-> item [0];
           if（rsp> = end）break;
           s = find_member（sd-> src）;

           for（; rsp-> type; rsp = rspn）{
               rspn =（rtcp_sdes_item_t *）（（char *）rsp + rsp-> length + 2）;
               if（rspn> = end）{
                   rsp = rspn;
                   打破;
               }
               member_sdes（s，rsp-> type，rsp-> data，rsp-> length）;
           }
           sd =（rtcp_sdes_t *）
                （（u_int32 *）sd +（（（char *）rsp  - （char *）sd）>> 2）+1）;
       }
       if（count> = 0）{
           / *无效数据包格式* /
       }
   }

A.6生成随机32位标识符

   以下子程序使用随机的32位标识符生成
   在RFC 1321 [ 32 ]中公布的MD5例程。系统例程可能
   不存在于所有操作系统上，但它们应该作为
   提示可以使用什么样的信息。其他系统
   可能适合的电话包括






Schulzrinne等人 标准履历[第85页]
 
RFC 3550                           RTP July 2003


   getdomainname（），

   o getwd（）或

   o getrusage（）。

   “直播”视频或音频样本也是一个很好的随机来源
   数字，但必须注意避免使用关闭
   麦克风或盲人相机作为来源[ 17 ]。

   建议使用此或类似程序生成
   产生RTCP的随机数发生器的初始种子
   期间（如附录A.7所示），以生成初始值
   序列号和时间戳，并生成SSRC值。
   由于这个例程可能是CPU密集型的，它直接使用
   生成RTCP周期是不合适的，因为可预测性不是
   一个问题。请注意，此例程产生相同的结果
   重复调用直到系统时钟的值改变，除非
   为类型参数提供不同的值。

   / *
    *生成随机的32位数量。
    * /
   #include <sys / types.h> / * u_long * /
   #include <sys / time.h> / * gettimeofday（）* /
   #include <unistd.h> / * get ..（）* /
   #include <stdio.h> / * printf（）* /
   #include <time.h> / * clock（）* /
   #include <sys / utsname.h> / * Uname（）* /
   #include“global.h”/ *来自RFC 1321 * /
   #include“md5.h”/ * from RFC 1321 * /

   #define MD_CTX MD5_CTX
   #define MDInit MD5Init
   #define MDUpdate MD5Update
   #define MDFinal MD5Final

   static u_long md_32（char * string，int length）
   {
       MD_CTX上下文
       工会{
           char [16];
           u_long x [4];
       } 消化;
       u ong
       int i

       MDInit（＆context）;



Schulzrinne等人 标准履历[第86页]
 
RFC 3550                           RTP July 2003


       MDUpdate（＆context，string，length）;
       MDFinal（（unsigned char *）＆digest，＆context）;
       r = 0;
       for（i = 0; i <3; i ++）{
           r ^ = digest.x [i];
       }
       返回r
   } / * md_32 * /

   / *
    *返回随机无符号32位数量。使用'type'参数if
    *您需要紧密地生成几个不同的值。
    * /
   u_int32 random32（int type）
   {
       struct {
           int类型;
           struct timeval tv;
           clock_t cpu;
           pid_t pid;
           呃
           uid_t uid;
           gid_t gid;
           struct utsname name;
       } s

       gettimeofday（＆s.tv，0）;
       UNAME（＆s.name）;
       s.type = type;
       s.cpu = clock（）;
       s.pid = getpid（）;
       s.hid = gethostid（）;
       s.uid = getuid（）;
       s.gid = getgid（）;
       / *还：系统正常运行时间* /

       返回md_32（（char *）＆s，sizeof（s））;
   } / * random32 * /

A.7计算RTCP传输间隔

   以下功能实现RTCP发送和接收6.2节中描述的 
   规则。这些规则被编码在几个
   功能：

   o rtcp_interval（）计算确定性计算间隔，
      以秒为单位。参数在6.3节中定义。




Schulzrinne等人 标准轨迹[第87页]
 
RFC 3550                           RTP July 2003


   o当RTCP传输定时器到期时，OnExpire（）被调用。

   每当收到RTCP数据包时，都会调用OnReceive（）。

   OnExpire（）和OnReceive（）都有事件e作为参数。这是
   该参与者的下一个计划的事件，RTCP报告
   或BYE数据包。假设以下功能是
   可供选择：

   o时间表（时间t，事件e）安排事件e在时间t发生。
      当时间t到达时，函数OnExpire用e作为调用
      论据。

   o重新安排（时间t，事件e）重新安排以前计划
      时间t的事件e。

   o SendRTCPReport（事件e）发送RTCP报告。

   o SendBYEPacket（事件e）发送BYE数据包。

   o如果事件是，TypeOfEvent（event e）返回EVENT_BYE
      处理的是用于发送BYE数据包，否则返回
      EVENT_REPORT。

   如果数据包p是RTCP，则PacketType（p）返回PACKET_RTCP_REPORT
      报告（不是BYE），PACKET_BYE如果是BYE RTCP数据包，
      PACKET_RTP如果是一个常规的RTP数据包。

   o ReceivedPacketSize（）和SentPacketSize（）返回的大小
      引用的数据包以八位字节为单位。

   o如果发送数据包p的参与者是，NewMember（p）返回1
      目前不在会员列表中，否则为0。注意这个功能
      因为每个中国证监会都不能完全实施
      RTP分组中的标识符和BYE分组中的每个SSRC应该
      被处理。

   o如果发送数据包p的参与者是，NewSender（p）返回1
      当前不在成员列表的发件人子列表中，0
      除此以外。

   o AddMember（）和RemoveMember（）来添加和删除参与者
      会员名单。

   o AddSender（）和RemoveSender（）来添加和删除参与者
      成员列表的发件人子列表。





Schulzrinne等人 标准履历[第88页]
 
RFC 3550                           RTP July 2003


   这些功能必须被扩展为一个实现
   允许发送者和非发件人的RTCP带宽分数
   指定为显式参数，而不是25％的固定值
   75％。rtcp_interval（）的扩展实现将需要
   如果其中一个参数为零，则避免除以零。

   double rtcp_interval（int members，
                        int发件人，
                        双rtcp_bw，
                        int we_sent，
                        double avg_rtcp_size，
                        int初始）
   {
       / *
        *来自此站点的RTCP数据包之间的最小平均时间
        *秒）。这一次可以防止报告“聚集”
        *会议很少，大量的法律没有帮助
        *平滑流量。它也保持报告间隔
        *在短暂停电期间变得可笑的小
        *网络分区。
        * /
       double const RTCP_MIN_TIME = 5;
       / *
        * RTCP带宽的分数在活动中共享
        *发件人。（这个部分被选中，使得在一个典型的
        *会话与一个或两个活跃的发件人，计算报告
        *时间大致等于最小报告时间
        *我们不会不必要地减慢接收机报告。）
        *接收者分数必须为1  - 发送者分数。
        * /
       double const RTCP_SENDER_BW_FRACTION = 0.25;
       double const RTCP_RCVR_BW_FRACTION =（1-RTCP_SENDER_BW_FRACTION）;
       / *
       / *补偿“定时器重新考虑”收敛到a
        *值低于预期平均水平。
        * /
       double const COMPENSATION = 2.71828  -  1.5;

       成对的东西; / *间隔* /
       double rtcp_min_time = RTCP_MIN_TIME;
       int n; / *否。的计算成员* /

       / *
        *在应用程序启动时非常首次呼叫使用半分钟
        *延迟更快的通知，同时仍然允许一些时间
        *报告为随机化，并了解其他
        *来源，所以报告间隔将收敛到正确
        *间隔更快。



Schulzrinne等人 标准履历[第89页]
 
RFC 3550                           RTP July 2003


        * /
       if（initial）{
           rtcp_min_time / = 2;
       }
       / *
        *专用于发送者的一部分RTCP带宽，除非
        发送者的数量足够大，以至于他们的份额是
        *多于该分数。
        * /
       n =会员
       if（senders <= members * RTCP_SENDER_BW_FRACTION）{
           if（we_sent）{
               rtcp_bw * = RTCP_SENDER_BW_FRACTION;
               n =发件人
           } else {
               rtcp_bw * = RTCP_RCVR_BW_FRACTION;
               n  -  =发件人
           }
       }

       / *
        *平均数据包大小的有效站点数量是
        *每个站点发送报告时发送的八位字节总数。
        *将有效带宽划分给时间
        *必须发送这些数据包的间隔时间
        *满足带宽目标，最小执行。在那里面
        *我们发送一个报告的时间间隔，所以这次也是我们的
        *报告之间的平均时间。
        * /
       t = avg_rtcp_size * n / rtcp_bw;
       if（t <rtcp_min_time）t = rtcp_min_time;

       / *
        *避免流量突发与非预期的同步
        *其他网站，然后选择我们实际的下一个报告间隔
        *随机数均匀分布在0.5 * t和1.5 * t之间。
        * /
       t = t *（drand48（）+ 0.5）;
       t = t /补偿;
       返回t
   }

   void OnExpire（event e，
                 int成员，
                 int发件人，
                 双rtcp_bw，
                 int we_sent，
                 double * avg_rtcp_size，



Schulzrinne等人 标准履历[第90页]
 
RFC 3550                           RTP July 2003


                 int * initial，
                 time_tp tc，
                 time_tp * tp，
                 int * pmembers）
   {
       / *此功能负责决定是否发送
        * RTCP报告或BYE分组，或重新安排传输。
        *它还负责更新pmembers，初始，tp，
        *和avg_rtcp_size状态变量。这个功能应该是
        *调用Schedule（）使用的事件计时器的到期时间。
        * /

       成对的东西; / *间隔* /
       双tn / *下一个传输时间* /

       / *在BYE的情况下，我们使用“定时器重新考虑”
        *必要时重新安排BYE的传输* /

       if（TypeOfEvent（e）== EVENT_BYE）{
           t = rtcp_interval（members，
                             发件人，
                             rtcp_bw，
                             我们发送，
                             * avg_rtcp_size，
                             *初始）;
           tn = * tp + t;
           if（tn <= tc）{
               SendBYEPacket（E）;
               出口（1）;
           } else {
               附表（tn，e）;
           }

       } else if（TypeOfEvent（e）== EVENT_REPORT）{
           t = rtcp_interval（members，
                             发件人，
                             rtcp_bw，
                             我们发送，
                             * avg_rtcp_size，
                             *初始）;
           tn = * tp + t;
           if（tn <= tc）{
               SendRTCPReport（E）;
               * avg_rtcp_size =（1./16.)*SentPacketSize(e）+
                   （15./16.)*(*avg_rtcp_size）;
               * tp = tc;

               / *我们必须重绘间隔。不要重复使用



Schulzrinne等人 标准履历[第91页]
 
RFC 3550                           RTP July 2003


                  一个计算上面，因为它不是实际
                  分配相同，因为我们有条件
                  它足够小，导致数据包
                  发送* /

               t = rtcp_interval（members，
                                 发件人，
                                 rtcp_bw，
                                 我们发送，
                                 * avg_rtcp_size，
                                 *初始）;

               附表（T + TC，E）;
               * initial = 0;
           } else {
               附表（tn，e）;
           }
           *会员=会员
       }
   }

   void OnReceive（packet p，
                  事件e，
                  int *成员，
                  int * pm会员，
                  int *发件人，
                  double * avg_rtcp_size，
                  双* tp，
                  双tc，
                  双tn）
   {
       / *我们做什么取决于我们是否离开了这个团体
        *等待发送BYE（TypeOfEvent（e）== EVENT_BYE）或RTCP
        *报告。p表示刚收到的数据包。* /

       if（PacketType（p）== PACKET_RTCP_REPORT）{
           if（NewMember（p）&&（TypeOfEvent（e）== EVENT_REPORT））{
               使用addMember（P）;
               *成员+ = 1;
           }
           * avg_rtcp_size =（1./16.)*ReceivedPacketSize(p）+
               （15./16.)*(*avg_rtcp_size）;
       } else if（PacketType（p）== PACKET_RTP）{
           if（NewMember（p）&&（TypeOfEvent（e）== EVENT_REPORT））{
               使用addMember（P）;
               *成员+ = 1;
           }
           if（NewSender（p）&&（TypeOfEvent（e）== EVENT_REPORT））{



Schulzrinne等人 标准履历[第92页]
 
RFC 3550                           RTP July 2003


               AddSender（P）;
               *发件人+ = 1;
           }
       } else if（PacketType（p）== PACKET_BYE）{
           * avg_rtcp_size =（1./16.)*ReceivedPacketSize(p）+
               （15./16.)*(*avg_rtcp_size）;

           if（TypeOfEvent（e）== EVENT_REPORT）{
               if（NewSender（p）== FALSE）{
                   RemoveSender（P）;
                   *发件人 -  = 1;
               }

               if（NewMember（p）== FALSE）{
                   RemoveMember（P）;
                   *成员 -  = 1;
               }

               if（* members <* pmembers）{
                   tn = tc +
                       （（（double）* members）/（* pmembers））*（tn-tc）;
                   * tp = tc  - 
                       （（（double）* members）/（* pmembers））*（tc  -  * tp）;

                   / *重新安排下一次报告tn * /

                   重新安排（tn，e）;
                   * pmembers = *成员;
               }

           } else if（TypeOfEvent（e）== EVENT_BYE）{
               *成员+ = 1;
           }
       }
   }
















Schulzrinne等人 标准履历[第93页]
 
RFC 3550                           RTP July 2003


A.8估计区域间抖动

   下面的代码片段实现了第
   6.4.1节中给出的算法中给出的算法，用于计算统计方差的估计
   RTP数据的interarrival时间插入到interarrival抖动
   接待报告。输入是r> ts，来自的时间戳
   传入包和到达，当前时间在同一单位。
   这里指出来源的状态; s->过境保持亲戚
   以前的数据包的传输时间，s-> jitter保持
   估计抖动。接收报告的抖动字段为
   以时间戳单位测量，并表示为无符号整数，但
   抖动估计保持在浮点。作为每个数据包
   抖动估计更新：

      int transit = arrival-r-> ts;
      int d = transit  -  s-> transit;
      s-> transit = transit;
      如果（d <0）d = -d;
      s-> jitter + =（1./16。）*（（double）d-s-> jitter）;

   当生成接收报告块（向哪个rr分）时
   该成员，返回当前的抖动估计值：

      rr-> jitter =（u_int32）s-> jitter;

   或者，抖动估计可以保持为整数，但是
   缩放以减少舍入误差。计算是相同的除外
   最后一行：

      s-> jitter + = d  - （（s-> jitter + 8）>> 4）;

   在这种情况下，接收报告的估计采样为：

      rr-> jitter = s-> jitter >> 4;

















Schulzrinne等人 标准履历[第94页]
 
RFC 3550                           RTP July 2003


附录B  - RFC 1889的变更

   这个RFC大部分与RFC 1889相同。没有变化
   在线上的数据包格式只改变了规则和
   管理协议如何使用的算法。最大的变化是
   增强可扩展定时算法计算的时间
   发送RTCP数据包：

   o用于计算RTCP传输间隔的算法
      在6.2和6.3节中规定并附录A.7中说明
      被增加以包括“重新考虑”以最小化传输
      超过许多参与者加入的预期费率
      同时进行会议，并“反向重新考虑”减少
      虚假参与者超时的发生率和持续时间
      参加人数急剧下降。反向重新考虑是
      也可以在发送RTCP SR之前缩短延迟
      当从被动接收器转换到主动发送器模式时。

   o   第6.3.7节规定了控制RTCP BYE的新规则
      应该发送数据包，以避免大量的数据包发生
      许多参与者同时离开会议。

   o为不活动参与者保留状态的要求
      足够长的时间跨越典型的网络分区被删除
      从6.2.1节。在许多参与者加入的会议中
      一个短暂的时间，没有发送BYE，这个要求会导致一个
      对参与人数的重视过高。该
      在本修订中添加的重新考虑算法补偿
      大量新参加者同时加入
      分区治愈

   应该指出的是，这些增强只有很大的一个
   当会话参与人数大时（千）
   大部分参与者同时加入或离开。这个
   使实时网络中的测试变得困难。但是，算法
   经过彻底的分析和模拟验证
   性能。此外，增强算法被设计为
   与RFC 1889中的算法进行互操作，使程度
   在步骤连接期间减少多余的RTCP带宽是成比例的
   到实施增强的参与者的一小部分
   算法。两种算法的互操作已得到验证
   在实时网络上实验。

   其他功能变化是：

   o   第6.2.1节规定，实现只能存储一个
      抽样参与者的SSRC标识符以允许缩放
      非常大的会话。算法在RFC 2762 [ 21 ]中规定。



Schulzrinne等人 标准履历[第95页]
 
RFC 3550                           RTP July 2003


   o在6.2节中，指定RTCP发件人和非发件人
      带宽可以被设置为会话的单独参数
      比会话带宽的严格百分比，并且可以设置
      到零。RTP会话需要RTCP
      使用IP多播轻松。不过也有澄清
      补充说，关闭RTCP不推荐。

   ○在第6.2，6.3.1和附录A.7，它是指定的
      发件人获得专用RTCP以下的参与者数
      带宽从固定1/4变化到基于RTCP的比例
      发送方和非发送方带宽参数。
      没有带宽专用于发送者的条件
      没有发件人被删除，因为预期是一个
      暂时状态 它也保持非发件人使用发件人
      RTCP带宽，那是不想要的。

   o同样在6.2节中指定了最小RTCP间隔
      可能会被缩放到较小的值，用于高带宽会话，
      对于单播，初始RTCP延迟可以被设置为零
      会话。

   o定时参与者是基于一个数字的不活动
      的RTCP报告间隔使用接收器RTCP计算
      即使对于活动发送者也是带宽分数。

   o 7.2和7.3节规定了翻译和混音器
      为他们不再转发的源发送BYE数据包。

   o分层编码的规则更改在第2.4节中定义，
      6.3.9,8.3和11.在最后一个中，注意到
      地址和端口分配规则与SDP冲突
      规范，RFC 2327 [ 15 ]，但是这是打算的
      对RFC 2327的修订将放宽限制。

   o在RTP和RTCP中使用偶/奇端口对的约定
      第11节被澄清是指目的地港口。该
      如果两者都要求使用偶/奇端口对
      明确指定端口。对于单播RTP会话，
      可用于两个端部不同的端口对（第3，7.1
      和11）。

   o新的第10节增加了来解释要求
      使用RTP的应用中的拥塞控制。

   o在8.2节中，要求新的SSRC标识必须是
      每当源传输地址发生变化时都会选择
      放松说可以选择一个新的SSRC标识符。
      相应地，澄清了一个实现可能



Schulzrinne等人 标准轨迹[第96页]
 
RFC 3550                           RTP July 2003


      选择保留来自新源地址的数据包而不是
      两个之间发生SSRC冲突时存在的源地址
      其他参与者，应该如此应用
      诸如移动实体之类的一些来源的电话可能会改变
      在RTP会话过程中的地址。

   o缩写错误在RFC 1889打印的伪代码第8.2节中 
      的碰撞检测和分辨率算法
      已经通过将语法翻译成伪C语言来纠正，
      并且该算法已被修改以消除限制
      RTP和RTCP必须从相同的源端口号发送。

   o RTCP包的填充机制的描述是
      澄清，并且规定填充必须只适用于
      复合RTCP数据包的最后一个数据包。

   o在A.1节中，base_seq的初始化被更正为seq
      而不是seq  -  1，而且文本被更正了说坏了
      序号加1存储。max_seq的初始化
      和算法的其他变量与文本分离
      要明确，这个初始化必须除了以外
      调用init_seq（）函数（和一些字在RFC 1889中丢失
      当从源到输出格式处理文档时
      恢复）。

   o修正了A.3节丢失的数据包数量
      使用正极和负极限。

   o RTCP SR中“相对”NTP时间戳的规范
      现在将这些时间戳定义为最基础的
      常用的系统特定时钟，如系统正常运行时间，而不是
      在会话经过的时间，这不会是相同的多个
      应用程序在不同时间在同一台机器上启动。

   非功能变化：

   o指定接收者必须忽略有效载荷的数据包
      类型不明白

   o在图 2，浮点NTP时间戳记值被更正，
      一些缺少的前导零以十六进制数字加UTC
      指定了时区。

   o一年中的NTP时间戳不合时宜
      2036被解释。






Schulzrinne等人 标准轨迹[第97页]
 
RFC 3550                           RTP July 2003


   o注册RTCP数据包类型和SDES类型的策略
      在新的第15节 IANA注意事项中得到澄清。该
      建议实验者注册他们需要的数字
      那么注销那些被证明是不需要的东西已被删除
      赞成使用APP和PRIV。档案名称的注册是
      也指定。

   o UTF-8字符集的引用从a更改
      X / Open初步规范为RFC 2279。

   o RFC 1597的引用已更新为RFC 1918和
      参考RFC2543，被更新为RFC 3261。

   o RFC 1889中介绍的最后一段，其中
      告诫实施者限制在互联网上的部署
      被删除，因为它被认为不再相关。

   o关于使用RTP与源特定的非规范性注释第6节 
      添加了组播（SSM）。

   o 第3节 “RTP会话”的定义已扩展到
      确认单个会话可能使用多个目的地
      运输地址（和翻译者一样）
      混音器），并解释RTP的区别特征
      会话是每个对应于单独的SSRC标识符
      空间。添加了“多媒体会话”的新定义
      减少对“会话”一词的混淆。

   o“采样瞬间”的含义更详细地解释
      RTP头部的时间戳字段的定义的一部分
      第5.1节。

   o在几个地方对文本进行了小量的澄清，
      一些回应读者的问题。尤其是：

      - 在RFC 1889中，第2.2节第二句的前五个词
         在处理源文件时丢失
         输出形式，但现在恢复。

      -在溶液中加入一种“RTP媒体类型”的定义第3节至
         允许在第
         5.2 节中多路复用RTP会话的解释对于多路复用更为清楚
         媒体。该部分现在也解释了多路复用
         基于SSRC标识符的同一介质的多个源
         可能是适当的，并且是多播会话的标准。

      - “非RTP手段”的定义扩大到包括
         构成非RTP手段的其他协议的示例。



Schulzrinne等人 标准轨迹[第98页]
 
RFC 3550                           RTP July 2003


      - 扩展会话带宽参数的描述
         在第6.2节中，包括澄清控制
         流量带宽除了会话带宽之外
         数据流量。

      - 变化包持续时间对抖动计算的影响
         在6.4.4节中有解释。

      - 终止和填充SDES项目序列的方法
         在第6.5节中得到澄清。

      - 在SDES的描述中添加了IPv6地址示例
         CNAME在6.5.1节和“example.com”代替
         其他示例域名。

      - 安全部门现在添加了对IPSEC的正式参考
         它是可用的，并说保密方法
         本规范中定义的主要是编纂现有的
         实践。建议加强加密
         使用诸如Triple-DES的算法来代替默认值
         算法，并注意到基于AES的SRTP简档将是
         未来的正确选择。关于弱点的警惕
         的RTP头作为初始化向量。它
         还注意到，仅有效载荷加密是必需的
         允许头压缩。

      -  RTCP部分加密方法得到了澄清; 在
         特别是，SDES CNAME只在一个部分被携带
         复合RTCP数据包被拆分。

      - 说明只有一个复合RTCP数据包应该是
         每个报告间隔发送，如果有太多的话
         报告的主动来源适合MTU，然后是一个子集
         的来源应该选择循环多个
         间隔。

      - 在附录A.1中添加了一个注释，可能会保存数据包
         在RTP报头验证和成功交付。

      -   第7.3节现在解释了混合器聚合SDES数据包
         由于更长的数据包，使用更多的RTCP带宽和一个混频器
         通过RTCP自然地发送高于该数据包的数据包
         单一来源率，但两种行为都是有效的。

      -   第13节阐明RTP应用可能使用多个
         配置文件，但通常在给定会话中只有一个。





Schulzrinne等人 标准履历[第99页]
 
RFC 3550                           RTP July 2003


      - 术语MUST，SHOULD，MAY等按照RFC 
         2119的定义使用。

      - 参考书目分为规范性和信息性
         引用。

参考

规范性参考

   [ 1 ] Schulzrinne，H.和S.Casner，“RTP Profile for Audio and Video
        Conferencing with Minimal Control“，RFC 3551，2003年7月。

   [ 2 ] Bradner，S.，“关键词在RFC中用于指示要求
        Level“，BCP 14，RFC 2119，1997年3月。

   [ 3 ] Postel，J.，“互联网协议”，STD 5，RFC 791，1981年9月。

   [ 4 ] Mills，D.，“Network Time Protocol（Version 3）Specification，
        实施和分析“，RFC 1305，1992年3月。

   [ 5 ] Yergeau，F.，“UTF-8，a Transformation Format of ISO 10646”，RFC 
        2279，1998年1月。

   [ 6 ] Mockapetris，P.，“域名 - 概念与设施”，STD
        13，RFC 1034，1987年11月。

   [ 7 ] Mockapetris，P.，“域名 - 实现和
        Specification“，STD 13，RFC 1035，1987年11月。

   [ 8 ] Braden，R.，“要求互联网主机 - 应用程序和
        支持“，STD 3，RFC 1123，1989年10月。

   [ 9 ] Resnick，P.，“Internet Message Format”，RFC 2822，2001年4月。

资料性参考

   [ 10 ] Clark，D.和D. Tennenhouse，“建筑注意事项
        新一代协议“，在SIGCOMM研讨会上
        通信架构和协议（Philadelphia，
        宾夕法尼亚州），pp。200--208，IEEE Computer Communications
        综述，Vol。20（4），1990年9月。

   [ 11 ] Schulzrinne，H.，“在设计传输协议中的问题
        音视频会议和其他多人实时会议
        申请“，1993年10月过期的互联网草案。





Schulzrinne等人 标准履历[第100页]
 
RFC 3550                           RTP July 2003


   [ 12 ] Comer，D.，Internetworking with TCP / IP，vol。恩格伍德
        悬崖，新泽西州：Prentice Hall，1991年。

   [ 13 ] Rosenberg，J.，Schulzrinne，H.，Camarillo，G.，Johnston，A.，
        Peterson，J.，Sparks，R.，Handley，M.and E. Schooler，“SIP：
        会话发起协议“，RFC 3261，2002年6月。

   [ 14 ]国际电信联盟“视觉电话系统”
        以及用于局域网的设备，
        保证服务质量“，建议H.323，
        国际电联电信标准化部门，日内瓦，
        瑞士，2003年7月。

   [ 15 ] Handley，M.和V. Jacobson，“SDP：Session Description”
        Protocol“，RFC 2327，1998年4月。

   [ 16 ] Schulzrinne，H.，Rao，A.and R. Lanphier，“Real Time Streaming”
        协议（RTSP）“，RFC 2326，1998年4月。

   [ 17 ] Eastlake 3rd，D.，Crocker，S.and J. Schiller，“Randomness
        建议安全“，RFC 1750，1994年12月。

   [ 18 ] Bolot，J.-C.，Turletti，T.和I.Wakeman，“Scalable Feedback”
        控制互联网中的组播视频分发“，in
        SIGCOMM通信架构与协议研讨会，
        （伦敦，英国），第58-67页，ACM，1994年8月。

   [ 19 ] Busse，I.，Deffner，B.和H. Schulzrinne，“Dynamic QoS Control
        基于RTP的多媒体应用“计算机
        通讯，第 19，pp。49-58，1996年1月。

   [ 20 ] Floyd，S.and V. Jacobson，“The Synchronization of Periodic
        路由消息“，在SIGCOMM通信研讨会上
        建筑与协议（DP Sidhu，ed。），（旧金山，
        加利福尼亚州），pp.33-44，ACM，1993年9月。也在[ 34 ]。

   [ 21 ] Rosenberg，J.和H. Schulzrinne，“集团的抽样
        RTP的成员资格“，RFC 2762，2000年2月。

   [ 22 ] Cadzow，J.，Digitalations Processing and Data的基础
        分析纽约纽约：麦克米伦，1987年。

   [ 23 ] Hinden，R.和S. Deering，“互联网协议版本6（IPv6）
        寻址架构“，RFC 3513，2003年4月。

   [ 24 ] Rekhter，Y.，Moskowitz，B.，Karrenberg，D.，de Groot，G.and E.
        Lear，“Private Allocation for Private Internets”，RFC 1918，
        1996年2月。



Schulzrinne等人 标准履历[第101页]
 
RFC 3550                           RTP July 2003


   [ 25 ] Lear，E.，Fair，E.，Crocker，D.and T.Kessler，“Network 10
        认为有害（一些做法不应编纂）“，RFC 
        1627，1994年7月。

   [ 26 ] Feller，W.，An Introduction to Probability Theory and Its
        应用，vol。纽约纽约：约翰·威利和儿子，
        第三版，1968年。

   [ 27 ] Kent，S.and R. Atkinson，“Security Architecture for the
        互联网协议“，RFC 2401，1998年11月。

   [ 28 ] Baugher，M.，Blom，R.，Carrara，E.，McGrew，D.，Naslund，M.，
        Norrman，K.and D.Oran，“Secure Real-time Transport Protocol”，
        正在进行中，2003年4月。

   [ 29 ] Balenson，D.，“Internet Enhancement for Internet Electronic Mail：
        第III部分“，RFC 1423，1993年2月。

   [ 30 ] Voydock，V.和S. Kent，“安全机制在高层次”
        网络协议“，ACM Computing Surveys，第15卷，第135-171页，
        一九八三年六月

   [ 31 ] Floyd，S.，“拥塞控制原理”，BCP 41，RFC 2914，
        二零零零年九月。

   [ 32 ] Rivest，R.，“MD5 Message-Digest Algorithm”，RFC 1321，April
        1992年。

   [ 33 ] Stubblebine，S.，“多媒体安全服务”
        会议“，在第十六届全国计算机安全大会上，
        （巴尔的摩，马里兰州），第391--395页，1993年9月。

   [ 34 ] Floyd，S.and V. Jacobson，“The Synchronization of Periodic
        Routing Messages“，IEEE / ACM Transactions on Networking，第2卷，
        第122-136页，1994年4月。
















Schulzrinne等人 标准轨迹[第102页]
 
RFC 3550                           RTP July 2003


作者地址

   亨宁·舒兹宁（Henning Schulzrinne）
   计算机科学系
   哥伦比亚大学
   1214阿姆斯特丹大道
   纽约，NY 10027
   美国

   电子邮件：schulzrinne@cs.columbia.edu


   斯蒂芬·卡斯纳
   数据包设计
   3400 Hillview Avenue，3号楼
   Palo Alto，CA 94304
   美国

   电子邮件：casner@acm.org


   罗恩·弗雷德里克
   蓝色外套系统公司
   650 Almanor Avenue
   Sunnyvale，CA 94085
   美国

   电子邮件：ronf@bluecoat.com


   范·雅各布森
   数据包设计
   3400 Hillview Avenue，3号楼
   Palo Alto，CA 94304
   美国

   电子邮件：van@packetdesign.com














Schulzrinne等人 标准履历[第103页]
 
RFC 3550                           RTP July 2003


完整版权声明

   版权所有（C）互联网协会（2003）。版权所有。

   该文件及其翻译可能会被复制和提供
   其他人，以及评论或以其他方式解释的衍生作品
   或协助其实施可以准备，复制，发布
   全部或部分分发，不受任何限制
   只要上述版权声明和本段是
   包括在所有这些副本和衍生作品。不过这个
   文档本身不得以任何方式进行修改，例如删除
   版权声明或参考互联网协会或其他
   互联网组织，除了需要为目的
   开发互联网标准在哪种情况下的程序
   必须在互联网标准过程中定义的版权
   按照或按照要求将其翻译成不同的语言
   英语。

   上述授予的限制是永久性的，不会是
   由互联网协会或其继承人或受让人撤销。

   本文档和本文中包含的信息提供在
   “按原样”的基础和互联网协会和互联网工程
   任何强制性声明均不承担任何明示或默示的担保，包括
   但不限于使用信息的任何担保
   此处不会侵犯任何权利或任何暗示的担保
   适销性或特定用途的适用性。

承认

   RFC编辑器功能的资金目前由...提供
   互联网协会



















Schulzrinne等人 标准履历[第104页]


由rfcmarkup 1.121生成的Html标记，可从 https://tools.ietf.org/tools/rfcmarkup/